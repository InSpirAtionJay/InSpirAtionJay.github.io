<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Markdown flowchart.js画流程图]]></title>
    <url>%2F2019%2F05%2F28%2FMarkdown-flowchart.js%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Markdown笔记：如何画流程图 Flowchart.js 仅需几行代码即可在 Web 上完成流程图的构建。可以从文字表述中画出简单的 SVG 流程图，也可以画出彩色的图表。 先来看一段入门案例流程图代码在 Markdown 编辑中应该是下面这样的(由于渲染的问题，请把,,,去掉)1234567891011,,,flowst=&gt;start: Starte=&gt;end: Endop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yes or No?io=&gt;inputoutput: catch something...st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1,,, 输出结果如图所示: 在markdown语法中，流程图的画法和代码段类似，也就是说，流程图是写在两个```之间的。比如说php代码，会是这样一种格式:]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORB-SLAM2源码分析二]]></title>
    <url>%2F2019%2F05%2F28%2FORB-SLAM2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Tracking 线程分析 st=>start: 开始 e=>end: 结束 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond cond(yes)->e cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>ORB-SLAM2</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORB-SLAM2源码分析一]]></title>
    <url>%2F2019%2F05%2F28%2FORB-SLAM2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80%2F</url>
    <content type="text"><![CDATA[主函数说明 mono_kitty.cc1. main 入口函数，读取3个文件参数，初始化系统 strVocFile: 字典词包的路径 strSettingFile: 系统中装有一些如相机参数、view窗口的配置文件，格式为YAML strSequence: 数据集路径 2. LoadImages 函数 LoadImages(const string &amp;strPathToSequence, vector &amp;vstrImageFilenames, vector &amp;vTimestamps) 12345678910111213141516171819202122232425262728293031 void LoadImages(const string &amp;strPathToSequence, vector&lt;string&gt; &amp;vstrImageFilenames, vector&lt;double&gt; &amp;vTimestamps)&#123; ifstream fTimes; string strPathTimeFile = strPathToSequence + "/times.txt"; fTimes.open(strPathTimeFile.c_str()); while(!fTimes.eof()) &#123; string s; getline(fTimes,s); if(!s.empty()) &#123; stringstream ss; ss &lt;&lt; s; double t; ss &gt;&gt; t; vTimestamps.push_back(t); &#125; &#125; string strPrefixLeft = strPathToSequence + "/image_0/"; const int nTimes = vTimestamps.size(); vstrImageFilenames.resize(nTimes); for(int i=0; i&lt;nTimes; i++) &#123; stringstream ss; ss &lt;&lt; setfill('0') &lt;&lt; setw(6) &lt;&lt; i; vstrImageFilenames[i] = strPrefixLeft + ss.str() + ".png"; &#125;&#125; 加载数据集函数，函数执行完vstrImageFileNames是一个存有图片具体位置的vector，位置形式如xxx/xxx/000xxx.png，vTimestamps是存有图片时间戳的vector 3. 实例化 SLAM 系统加载图片路径完成后，需要实例化一个SLAM系统对象ORB_SLAM2::System SLAM(argv[1],argv[2],ORB_SLAM2::System::MONOCULAR,true); System.h 包含了7个类，分别是Viewer， FrameDrawer, Map, Tracking, LocalMapping, LoopClosing 的声明，和System 类的定义， 就像描述的那样，这些类组成了一个系统。 1234567class Viewer;class FrameDrawer;class Map;class Tracking;class LocalMapping;class LoopClosing;class System; 成员变量说明3.1 sensor 枚举12345enum eSensor&#123; MONOCULAR=0, STEREO=1, RGBD=2&#125;; 0,1,2 分别代表传感器的类型 3.2 System 构造函数System(const string &amp;strVocFile, const string &amp;strSettingsFile, const eSensor sensor, const bool bUseViewer = true); Monocular System 构造时，读入词包路径，YAML配置文件，设置eSensor类型为Monocular，并启用Viewer线程 3.3 Tracking 函数123456789101112131415// Proccess the given stereo frame. Images must be synchronized and rectified.// Input images: RGB (CV_8UC3) or grayscale (CV_8U). RGB is converted to grayscale.// Returns the camera pose (empty if tracking fails).cv::Mat TrackStereo(const cv::Mat &amp;imLeft, const cv::Mat &amp;imRight, const double &amp;timestamp);// Process the given rgbd frame. Depthmap must be registered to the RGB frame.// Input image: RGB (CV_8UC3) or grayscale (CV_8U). RGB is converted to grayscale.// Input depthmap: Float (CV_32F).// Returns the camera pose (empty if tracking fails).cv::Mat TrackRGBD(const cv::Mat &amp;im, const cv::Mat &amp;depthmap, const double &amp;timestamp);// Proccess the given monocular frame// Input images: RGB (CV_8UC3) or grayscale (CV_8U). RGB is converted to grayscale.// Returns the camera pose (empty if tracking fails).cv::Mat TrackMonocular(const cv::Mat &amp;im, const double &amp;timestamp); 针对不同传感器不同的Tracking。输入图像可以使rgb的也可以是grayscale的（最终读进去都会转化为grayscale的），函数返回值为camera的位姿pose。Tracking 过程是对针对每一幅图像，通过先初始化然后track和优化过程来估计相机误差。 3.4 定位模式函数1234// This stops local mapping thread (map building) and performs only camera tracking.void ActivateLocalizationMode();// This resumes local mapping thread and performs SLAM again.void DeactivateLocalizationMode(); 调用ActivateLocalizationMode()将终止mapping线程，开启定位模式，调用后者重启mapping线程。 3.5 重启与终止函数1234567// Reset the system (clear map)void Reset();// All threads will be requested to finish.// It waits until all threads have finished.// This function must be called before saving the trajectory.void Shutdown(); Reset()函数将清空map，Shutdown()函数可以终止所有线程，在保存相机轨迹之前需要调用此函数。 3.6 SaveTrajectory 函数123456789101112131415161718192021// Save camera trajectory in the TUM RGB-D dataset format.// Only for stereo and RGB-D. This method does not work for monocular.// Call first Shutdown()// See format details at: http://vision.in.tum.de/data/datasets/rgbd-datasetvoid SaveTrajectoryTUM(const string &amp;filename);// Save keyframe poses in the TUM RGB-D dataset format.// This method works for all sensor input.// Call first Shutdown()// See format details at: http://vision.in.tum.de/data/datasets/rgbd-datasetvoid SaveKeyFrameTrajectoryTUM(const string &amp;filename);// Save camera trajectory in the KITTI dataset format.// Only for stereo and RGB-D. This method does not work for monocular.// Call first Shutdown()// See format details at: http://www.cvlibs.net/datasets/kitti/eval_odometry.phpvoid SaveTrajectoryKITTI(const string &amp;filename);// TODO: Save/Load functions// SaveMap(const string &amp;filename);// LoadMap(const string &amp;filename); 把相机轨迹保存成相应数据集的格式，系统调用此函数时先shutdown SLAM系统，mono_kittti中save函数用的是SaveKeyFrameTrajectoryTUM，这个函数看起来像是只能用于TUM数据集，但三种传感器均适合。 4 System private 成员变量说明4.1 eSensor12// Input sensoreSensor mSensor; 输入的传感器类型 4.2 mpVocabulary12// ORB vocabulary used for place recognition and feature matching.ORBVocabulary* mpVocabulary; 用于位置识别和特征匹配的系统词包 4.3 mpKeyFrameDatabase12// KeyFrame database for place recognition (relocalization and loop detection).KeyFrameDatabase* mpKeyFrameDatabase; 用于位置识别，重定位，回环检测的关键帧数据集 4.4 mpMap12// Map structure that stores the pointers to all KeyFrames and MapPoints.Map* mpMap; 存储系统关键帧的指针和地图点的指针 4.5 mpTracker1234// Tracker. It receives a frame and computes the associated camera pose.// It also decides when to insert a new keyframe, create some new MapPoints and// performs relocalization if tracking fails.Tracking* mpTracker; Tracker 接受一帧图像并计算相机位姿，决定什么时候需要插入关键帧，创建地图点并且执行重定位如果跟踪失败。 4.6 mpLocalMapper12// Local Mapper. It manages the local map and performs local bundle adjustment.LocalMapping* mpLocalMapper; 局部地图管理器，mpLocalMapper，管理局部地图并进行局部BA。 4.7 mpLoopCloser123// Loop Closer. It searches loops with every new keyframe. If there is a loop it performs// a pose graph optimization and full bundle adjustment (in a new thread) afterwards.LoopClosing* mpLoopCloser; 回环检测器，每次获取关键帧后都会进行回环检测，如果存在回环的话就执行位姿图的优化并且进行全局BA优化 4.8 mpViewer,mpFrameDrawer,mpMapDrawer12345// The viewer draws the map and the current camera pose. It uses Pangolin.Viewer* mpViewer;FrameDrawer* mpFrameDrawer;MapDrawer* mpMapDrawer; 视图显示 4.9 系统线程12345// System threads: Local Mapping, Loop Closing, Viewer.// The Tracking thread "lives" in the main execution thread that creates the System object.std::thread* mptLocalMapping;std::thread* mptLoopClosing;std::thread* mptViewer; 4.10 Reset flag123// Reset flagstd::mutex mMutexReset;bool mbReset; 4.11 Change mode flags1234// Change mode flagsstd::mutex mMutexMode;bool mbActivateLocalizationMode;bool mbDeactivateLocalizationMode; 5. 实例化SLAM-System构造函数123System::System(const string &amp;strVocFile, const string &amp;strSettingsFile, const eSensor sensor, const bool bUseViewer):mSensor(sensor),mbReset(false),mbActivateLocalizationMode(false), mbDeactivateLocalizationMode(false) System 构造函数用于实例化一个SALM系统，开启相机跟踪(Tracking)，局部建图(Local Mapping)，回环检测(Loop Closing)，和可视化界面(Viewer)的线程。 5.1 初始形参传递1234mSensor(sensor),mbReset(false),mbActivateLocalizationMode(false),mbDeactivateLocalizationMode(false) sensor是传进来的形参，是前面枚举体中三种传感器的一个，这里为MONOCULAR，它传递给了mSensor，这是一个System类的隐含成员变量，两种变量类型一样。mpViewer是System类的隐含成员变量，Viewer类指针，这里赋空。mbReset，mbActivateLocalizationMode，mbDeactivateLocalizationMode均为bool型，赋false。 5.2 初始化数据库 1 初始化词包 mpVocabulary 123456789101112131415161718//Load ORB Vocabulary cout &lt;&lt; endl &lt;&lt; "Loading ORB Vocabulary. This could take a while..." &lt;&lt; endl; mpVocabulary = new ORBVocabulary(); bool bVocLoad = false; // chose loading method based on file extension if (has_suffix(strVocFile, ".txt")) bVocLoad = mpVocabulary-&gt;loadFromTextFile(strVocFile); else if(has_suffix(strVocFile, ".bin")) bVocLoad = mpVocabulary-&gt;loadFromBinaryFile(strVocFile); else bVocLoad = false; if(!bVocLoad) &#123; cerr &lt;&lt; "Wrong path to vocabulary. " &lt;&lt; endl; cerr &lt;&lt; "Failed to open at: " &lt;&lt; strVocFile &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; "Vocabulary loaded!" &lt;&lt; endl &lt;&lt; endl; 2 用词包数据库来初始化关键帧数据库（用于重定位和回环检测）mpKeyFrameDatabase 12//Create KeyFrame Database mpKeyFrameDatabase = new KeyFrameDatabase(*mpVocabulary); 3 初始化一个Map类对象 ，该类用于存储指向所有关键帧和地图点的指针 mpMap 12//Create the Map mpMap = new Map(); 4 初始化画图工具，用于可视化 mpFrameDrawer、mpMapDrawer 123//Create Drawers. These are used by the Viewer mpFrameDrawer = new FrameDrawer(mpMap); mpMapDrawer = new MapDrawer(mpMap, strSettingsFile); 5 初始化Tracking线程，主线程，使用this指针（只初始化不启动，启动在main函数里TrackMonocular()启动） 1234//Initialize the Tracking thread//(it will live in the main thread of execution, the one that called this constructor) mpTracker = new Tracking(this, mpVocabulary, mpFrameDrawer, mpMapDrawer, mpMap, mpKeyFrameDatabase, strSettingsFile, mSensor); 6 初始化Local Mapping线程并启动（这里mSensor传入MONOCULAR）mpLocalMapper 123//Initialize the Local Mapping thread and launch mpLocalMapper = new LocalMapping(mpMap, mSensor==MONOCULAR); mptLocalMapping = new thread(&amp;ORB_SLAM2::LocalMapping::Run,mpLocalMapper); 7 初始化Loop Closing线程并启动（这里mSensor传入的不是MONOCULAR）mptLoopClosing 123//Initialize the Loop Closing thread and launchmpLoopCloser = new LoopClosing(mpMap, mpKeyFrameDatabase, mpVocabulary, mSensor!=MONOCULAR);mptLoopClosing = new thread(&amp;ORB_SLAM2::LoopClosing::Run, mpLoopCloser); 8 初始化Viewer线程并启动，也使用了this指针；给Tracking线程设置Viewer 123456//Initialize the Viewer thread and launch mpViewer = new Viewer(this, mpFrameDrawer,mpMapDrawer,mpTracker,strSettingsFile); if(bUseViewer) mptViewer = new thread(&amp;Viewer::Run, mpViewer); mpTracker-&gt;SetViewer(mpViewer); 9 mpTracker，mpLocalMapper，mptLoopClosing三个线程每两个线程之间设置指针相互关联 123456789//Set pointers between threads mpTracker-&gt;SetLocalMapper(mpLocalMapper); mpTracker-&gt;SetLoopClosing(mpLoopCloser); mpLocalMapper-&gt;SetTracker(mpTracker); mpLocalMapper-&gt;SetLoopCloser(mpLoopCloser); mpLoopCloser-&gt;SetTracker(mpTracker); mpLoopCloser-&gt;SetLocalMapper(mpLocalMapper); 6. 循环Tracking12345678910111213141516171819202122232425262728293031323334353637383940414243444546 // Main loop cv::Mat im; for(int ni=0; ni&lt;nImages; ni++) &#123; // Read image from file im = cv::imread(vstrImageFilenames[ni],CV_LOAD_IMAGE_UNCHANGED); double tframe = vTimestamps[ni]; if(im.empty()) &#123; cerr &lt;&lt; endl &lt;&lt; "Failed to load image at: " &lt;&lt; vstrImageFilenames[ni] &lt;&lt; endl; return 1; &#125;#ifdef COMPILEDWITHC11 std::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::now();#else std::chrono::monotonic_clock::time_point t1 = std::chrono::monotonic_clock::now();#endif // Pass the image to the SLAM system SLAM.TrackMonocular(im,tframe);#ifdef COMPILEDWITHC11 std::chrono::steady_clock::time_point t2 = std::chrono::steady_clock::now();#else std::chrono::monotonic_clock::time_point t2 = std::chrono::monotonic_clock::now();#endif double ttrack= std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt; &gt;(t2 - t1).count(); vTimesTrack[ni]=ttrack; // Wait to load the next frame double T=0; if(ni&lt;nImages-1) T = vTimestamps[ni+1]-tframe; else if(ni&gt;0) T = tframe-vTimestamps[ni-1]; if(ttrack&lt;T) this_thread::sleep_for(std::chrono::microseconds((int)((T-ttrack)*1e6))); &#125; // Stop all threads SLAM.Shutdown(); 上述分为两步：读图、Tracking，其中有一部分代码（注释 //Wait to load the next frame 后）目的是为了模拟真实时间状况，如果tracking过快，则下一帧可能还没来，所以要“睡” T-ttrack 秒等待装载下一帧图片。每次tracking只处理一帧图片。]]></content>
      <categories>
        <category>ORB-SLAM2</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>Tracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git简单攻略]]></title>
    <url>%2F2019%2F05%2F24%2Fgit%E7%AE%80%E5%8D%95%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[git全局用户申明12git config --global user.name "Your Name"git config --global user.email "email@example.com" 创建管理库1git init 添加文件1git add reamde.md 提交文件到仓库1git commit -m "message" 为什么git提交文件需要add和commit两步呢，因为commit可以一次提交很多次add不同的文件，比如123git add file1.txtgit add file2.txt file3.txtgit commit -m "add 3files" 查看仓库状态1git status 查看文件修改内容1git diff readme.txt 查看提交历史1git log 以便确定回退到哪个版本。 查看命令历史1git reflog 以便确定回到未来的哪个版本。 版本指针HEAD指向的版本就是当前的版本，HEAD^指向前一个版本，HEAD^^指向前前版本，HEAD~100指向第前100个版本。因此，git允许我们在历史之间穿梭。 版本穿梭1git reset --hard commit_id 丢弃工作区的修改1git checkout -- file 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 从暂存区回到工作区1git reset HEAD readme.txt 如果你把文件git add到暂存区，但是还没有git commit到仓库，可以使用git reset HEAD file 将暂存区的修改撤销掉，重新放回到工作区。git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 小结场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout — file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件12git rm test.txtgit commit -m "remove test.txt" 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：rm test.txt。这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了。 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit，现在，文件就从版本库中被删除了。 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：1git checkout -- test.txt 小提示：先手动删除文件，然后使用git rm 和git add效果是一样的。注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！ 添加远程仓库1git remote add origin git@github.com:hahaha/hahaha.git 把本地库的所有内容推送到远程库上1git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 提交仓库到到远程1git push origin master 从远程库克隆1git clone git@github.com:hahaha/gitskills.git 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件：现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了： 转载申明本文转载自廖雪峰的博客：[https://www.liaoxuefeng.com]]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EKF详解]]></title>
    <url>%2F2019%2F05%2F23%2FEKF%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. 高斯函数\begin{equation}p(x) = \det(2\pi\Sigma)^{- \frac {1}{2} }\exp{ \{ -\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu) \}}\label{eq:Gaussion}\end{equation} 所有的高斯技术都共享了基本思想，即置信度用多元正态分布来表示。$x$的密度用两个参数来表示，均值$\mu$和协方差$\Sigma$，均值$\mu$是一个向量，它与状态$x$的维数相同。协方差是对称半正定的二次型。其维数等于状态$x$的维数的二次方。高斯滤波中的参数均值和方差称为矩参数，这是因为均值和方差是概率分布的一阶矩和二阶矩；正态分布的其他矩都是零。 2. 线性高斯系统KF是由Swerling（1950）和Kalman（1960）作为线性高斯系统中的预测和滤波技术而发明的，是用矩来定义的。KF用矩参数来表示置信度：在时刻$t$，置信度用均值$\mu_t$和方差$\Sigma_t$表示、如果除了贝叶斯滤波的马尔科夫假设以外，还具有如下的三个特性，则后验就是高斯的。 状态转移概率$p(x_t | u_t, x_{t-1})$必须是带有随机高斯噪声的参数的线性函数，可有下式表示:\begin{equation}x_t = A_tx_{t-1} + B_tu_t + \varepsilon_t\label{eq:motion}\end{equation}式中，$x_t$和$x_{t-1}$都是状态向量，它们都是$n$维列向量；$u_t$为时刻$t$的控制向量。式(2)中，$A_t$为$n \times n$的矩阵，$B_t$为$n \times m$的矩阵，$n$为状态向量$x_t$的维数，$m$为控制向量$u_t$的维数。式(2)中的随机变量\varepsilon_t是一个高斯随机向量，表示由状态转移引入的不确定性。其维数与状态向量维数相同，均值为0，方差用$R_t$表示。式(2)中的状态转移概率称为线性高斯，反映了它与带有附加高斯噪声的自变量呈线性关系。式(2)定义了状态转移概率$p(x_t | u_t, x_{t-1})$。这个概率可由公式(2)带入到多元正态分布的定义式(1)来得到。后验状态的均值由$A_tx_{t-1} + B_tu_t$给定，方差由$R_t$给定：\begin{equation}p(x_t | u_t, x_{t-1}) = \det(2\pi R_t)^{- \frac {1}{2} }\exp{ \{ -\frac{1}{2}(x_t-A_tx_{t-1} - B_tu_t)^TR_t^{-1}(x_t-A_tx_{t-1} - B_tu_t) \}}\label{eq:status}\end{equation} 观测概率$p(z_t | x_t)$也与带有高斯噪声的自变量呈线性关系：\begin{equation}z_t = C_tx_t + \delta _t\label{eq:project}\end{equation}式中，$C_t$为$k \times n$的矩阵，$k$为观测向量$z_t$的维数；向量$\delta _t$为观测噪声。$\delta _t$服从均值为0、方差为$Q_t$的多变量高斯分布。因此观测概率由下面的多元正态分布给定：\begin{equation}p(z_t | x_t) = \det(2\pi Q_t)^{- \frac {1}{2} }\exp{ \{ -\frac{1}{2}(z_t - C_tx_t)^TQ_t^{-1}(z_t-C_tx_t) \}}\label{eq:measure}\end{equation} 最后，初始置信度必须${\rm bel}(x_0)$必须是正态分布的。这里用$\mu_0$表示初始置信度的均值，用$\Sigma_0$表示协方差：\begin{equation}{\rm bel}(x_0) = p (x_0)= \det(2\pi \Sigma_0)^{- \frac {1}{2} }\exp{ \{ -\frac{1}{2}(x_0 - \mu_0)^T\Sigma_0^{-1}(x_0-\mu_0) \}}\label{eq:initial}\end{equation} 这三个假设足以保证后验${\rm bel}(x_t)$在任何时刻$t$总符合高斯分布。 3. KF算法(Kalman fliter algorithm)KF算法如图所示，KF表示均值为$\mu_t$、方差为$\Sigma_t$的状态量在时刻$t$的置信度{\rm bel}(x_t)。KF的输入是$t-1$时刻的置信度，其均值和方差分别用$\mu_{t-1}$和$\Sigma_{t-1}$表示。为了更新这些参数，KF需要控制向量$u_t$和测量向量$z_t$。输出的是时刻$t$的置信度，均值为$\mu_t$，方差为$\Sigma_t$。 Algorithm Kalman_filter($\mu_{t-1}$,$\Sigma_{t-1}$,$u_t$,$z_t$): 3.3 线性高斯系统]]></content>
      <categories>
        <category>SLAM</category>
      </categories>
      <tags>
        <tag>SLAM</tag>
        <tag>EKF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>
