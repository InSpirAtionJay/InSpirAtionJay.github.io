<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ORB-SLAM2源码分析三</title>
      <link href="/2019/05/29/ORB-SLAM2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89/"/>
      <url>/2019/05/29/ORB-SLAM2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="ORBextractor特征提取器"><a href="#ORBextractor特征提取器" class="headerlink" title="ORBextractor特征提取器"></a>ORBextractor特征提取器</h2><h3 id="1-ORBextractor-成员变量"><a href="#1-ORBextractor-成员变量" class="headerlink" title="1. ORBextractor 成员变量"></a>1. ORBextractor 成员变量</h3><h4 id="1-1-SCORE-得分常量"><a href="#1-1-SCORE-得分常量" class="headerlink" title="1.1 SCORE 得分常量"></a>1.1 SCORE 得分常量</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-描述子的筛选模式"><a href="#1-2-描述子的筛选模式" class="headerlink" title="1.2 描述子的筛选模式"></a>1.2 描述子的筛选模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point&gt; pattern;</span><br></pre></td></tr></table></figure><p>用来快速建立256维的描述子</p><h3 id="1-3-ORBextractor-特征提取器的控制变量"><a href="#1-3-ORBextractor-特征提取器的控制变量" class="headerlink" title="1.3 ORBextractor 特征提取器的控制变量"></a>1.3 ORBextractor 特征提取器的控制变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nfeatures;              <span class="comment">// 需要提取的特征点数目</span></span><br><span class="line"><span class="keyword">double</span> scaleFactor;         <span class="comment">// ORB 金字塔相邻两层之间的尺度因子</span></span><br><span class="line"><span class="keyword">int</span> nlevels;                <span class="comment">// 金字塔的层数</span></span><br><span class="line"><span class="keyword">int</span> iniThFAST;              <span class="comment">// FAST角点提取的初始阈值</span></span><br><span class="line"><span class="keyword">int</span> minThFAST;              <span class="comment">// FAST角点用初始阈值提取失败后放松阈值再次提取</span></span><br></pre></td></tr></table></figure><h3 id="1-4-每层金字塔对应的特征点数目Vector-mnFeaturesPerLevel"><a href="#1-4-每层金字塔对应的特征点数目Vector-mnFeaturesPerLevel" class="headerlink" title="1.4 每层金字塔对应的特征点数目Vector mnFeaturesPerLevel"></a>1.4 每层金字塔对应的特征点数目Vector <em>mnFeaturesPerLevel</em></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mnFeaturesPerLevel;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-5-每层金字塔对应的尺度因子Vector-mvScaleFactor"><a href="#1-5-每层金字塔对应的尺度因子Vector-mvScaleFactor" class="headerlink" title="1.5 每层金字塔对应的尺度因子Vector mvScaleFactor"></a>1.5 每层金字塔对应的尺度因子Vector <em>mvScaleFactor</em></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; mvScaleFactor;</span><br></pre></td></tr></table></figure><h3 id="1-6-每层金字塔对应的尺度因子的倒数Vector-mvInvScaleFactor"><a href="#1-6-每层金字塔对应的尺度因子的倒数Vector-mvInvScaleFactor" class="headerlink" title="1.6 每层金字塔对应的尺度因子的倒数Vector mvInvScaleFactor"></a>1.6 每层金字塔对应的尺度因子的倒数Vector <em>mvInvScaleFactor</em></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; mvInvScaleFactor;</span><br></pre></td></tr></table></figure><h3 id="1-7-每层金字塔对应的Sigma的平方Vector-mvLevelSigma2"><a href="#1-7-每层金字塔对应的Sigma的平方Vector-mvLevelSigma2" class="headerlink" title="1.7 每层金字塔对应的Sigma的平方Vector mvLevelSigma2"></a>1.7 每层金字塔对应的Sigma的平方Vector <em>mvLevelSigma2</em></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; mvLevelSigma2;</span><br></pre></td></tr></table></figure><h3 id="1-8-每层金字塔对应的Sigma的平方的倒数Vector-mvLevelSigma2"><a href="#1-8-每层金字塔对应的Sigma的平方的倒数Vector-mvLevelSigma2" class="headerlink" title="1.8 每层金字塔对应的Sigma的平方的倒数Vector mvLevelSigma2"></a>1.8 每层金字塔对应的Sigma的平方的倒数Vector <em>mvLevelSigma2</em></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; mvInvLevelSigma2;</span><br></pre></td></tr></table></figure><h3 id="1-9-每层金字塔对应图像Mat-mvImagePyramid"><a href="#1-9-每层金字塔对应图像Mat-mvImagePyramid" class="headerlink" title="1.9 每层金字塔对应图像Mat mvImagePyramid"></a>1.9 每层金字塔对应图像Mat <em>mvImagePyramid</em></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Mat&gt; mvImagePyramid;</span><br></pre></td></tr></table></figure><h3 id="2-ORBextractor-成员函数"><a href="#2-ORBextractor-成员函数" class="headerlink" title="2. ORBextractor 成员函数"></a>2. ORBextractor 成员函数</h3><h3 id="2-1-ORBextractor-构造函数"><a href="#2-1-ORBextractor-构造函数" class="headerlink" title="2.1 ORBextractor 构造函数"></a>2.1 ORBextractor 构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ORBextractor(<span class="keyword">int</span> nfeatures, <span class="keyword">float</span> scaleFactor, <span class="keyword">int</span> nlevels,</span><br><span class="line">                 <span class="keyword">int</span> iniThFAST, <span class="keyword">int</span> minThFAST);</span><br></pre></td></tr></table></figure><p>第一步：算金字塔每层的尺度，然后根据尺度计算每层应该提取多少特征点，这里面涉及了一个等比数列，唤起高中的记忆，还挺有意思的。最后，保证提取总特征点数≥ nfeatures。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mvScaleFactor.resize(nlevels);</span><br><span class="line">mvLevelSigma2.resize(nlevels);</span><br><span class="line">mvScaleFactor[<span class="number">0</span>]=<span class="number">1.0</span>f;</span><br><span class="line">mvLevelSigma2[<span class="number">0</span>]=<span class="number">1.0</span>f;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">1</span>; <span class="built_in">i</span>&lt;nlevels; <span class="built_in">i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    mvScaleFactor[<span class="built_in">i</span>]=mvScaleFactor[<span class="built_in">i</span><span class="number">-1</span>]*scaleFactor;</span><br><span class="line">    mvLevelSigma2[<span class="built_in">i</span>]=mvScaleFactor[<span class="built_in">i</span>]*mvScaleFactor[<span class="built_in">i</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mvInvScaleFactor.resize(nlevels);</span><br><span class="line">mvInvLevelSigma2.resize(nlevels);</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;nlevels; <span class="built_in">i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    mvInvScaleFactor[<span class="built_in">i</span>]=<span class="number">1.0</span>f/mvScaleFactor[<span class="built_in">i</span>];</span><br><span class="line">    mvInvLevelSigma2[<span class="built_in">i</span>]=<span class="number">1.0</span>f/mvLevelSigma2[<span class="built_in">i</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>nfeatures: 1000<br>nleves: 8<br>scaleFactor: 1.2<br>iniThFAST: 20<br>minThFAST: 8</p><p>mvScaleFactor: 1.0, 1.2, 1.2^2, 1.2^3, 1.2^4, 1.2^5, 1.2^6, 1.2^7<br>mvLevelSigma2: mvScaleFactor[i]*mvScaleFactor[i];<br>mvInvScaleFactor[i]=1.0f/mvScaleFactor[i];<br>mvInvLevelSigma2[i]=1.0f/mvLevelSigma2[i];<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float factor = <span class="number">1.0</span>f / scaleFactor<span class="comment">;</span></span><br><span class="line">float nDesiredFeaturesPerScale = nfeatures*(<span class="number">1</span> - factor)/(<span class="number">1</span> - (<span class="name">float</span>)pow((<span class="name">double</span>)factor, (<span class="name">double</span>)nlevels))<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p> 通过等比数列求和来计算初始第0层nDesiredFeaturesPerScale的特征点数</p><script type="math/tex; mode=display">{\rm nfeatures} = \frac{ {\rm nDesiredFeaturesPerScale}\times(1-{\rm factor}^{\rm nlevels})}{1-{\rm factor}}</script><script type="math/tex; mode=display">{\rm nDesiredFeaturesPerScale} = \frac{ {\rm nfeatures}\times(1-{\rm factor})}{1-{\rm factor}^{\rm nlevels}}</script><h3 id="1-2-ORBextractor-成员变量"><a href="#1-2-ORBextractor-成员变量" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-1"><a href="#1-2-ORBextractor-成员变量-1" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-2"><a href="#1-2-ORBextractor-成员变量-2" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-3"><a href="#1-2-ORBextractor-成员变量-3" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-4"><a href="#1-2-ORBextractor-成员变量-4" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-5"><a href="#1-2-ORBextractor-成员变量-5" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-6"><a href="#1-2-ORBextractor-成员变量-6" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-7"><a href="#1-2-ORBextractor-成员变量-7" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-8"><a href="#1-2-ORBextractor-成员变量-8" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-9"><a href="#1-2-ORBextractor-成员变量-9" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-10"><a href="#1-2-ORBextractor-成员变量-10" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-11"><a href="#1-2-ORBextractor-成员变量-11" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-12"><a href="#1-2-ORBextractor-成员变量-12" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-13"><a href="#1-2-ORBextractor-成员变量-13" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-14"><a href="#1-2-ORBextractor-成员变量-14" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-15"><a href="#1-2-ORBextractor-成员变量-15" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-16"><a href="#1-2-ORBextractor-成员变量-16" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-17"><a href="#1-2-ORBextractor-成员变量-17" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-18"><a href="#1-2-ORBextractor-成员变量-18" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-19"><a href="#1-2-ORBextractor-成员变量-19" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-20"><a href="#1-2-ORBextractor-成员变量-20" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p><h3 id="1-2-ORBextractor-成员变量-21"><a href="#1-2-ORBextractor-成员变量-21" class="headerlink" title="1.2 ORBextractor 成员变量"></a>1.2 ORBextractor 成员变量</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;<span class="attribute">HARRIS_SCORE</span>=0, <span class="attribute">FAST_SCORE</span>=1 &#125;;</span><br></pre></td></tr></table></figure><p>定义常量，HARRIS_SCORE=0, FAST_SCORE=1，特征点提取后通过得分进行筛选得到最佳的特征点</p>]]></content>
      
      
      <categories>
          
          <category> ORB-SLAM2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
            <tag> Tracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown flowchart.js画流程图</title>
      <link href="/2019/05/28/Markdown-flowchart.js%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
      <url>/2019/05/28/Markdown-flowchart.js%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="Markdown笔记：如何画流程图"><a href="#Markdown笔记：如何画流程图" class="headerlink" title="Markdown笔记：如何画流程图"></a>Markdown笔记：如何画流程图</h2><blockquote><p>Flowchart.js 仅需几行代码即可在 Web 上完成流程图的构建。可以从文字表述中画出简单的 SVG 流程图，也可以画出彩色的图表。 </p></blockquote><h3 id="1-先来看一段入门案例"><a href="#1-先来看一段入门案例" class="headerlink" title="1. 先来看一段入门案例"></a>1. 先来看一段入门案例</h3><p>流程图代码在 Markdown 编辑中应该是下面这样的(由于渲染的问题，请把,,,改成三个点号)<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">,,,flow</span><br><span class="line"><span class="attribute">st</span>=&gt;start: Start</span><br><span class="line"><span class="attribute">e</span>=&gt;end: End</span><br><span class="line"><span class="attribute">op1</span>=&gt;operation: My Operation</span><br><span class="line"><span class="attribute">sub1</span>=&gt;subroutine: My Subroutine</span><br><span class="line"><span class="attribute">cond</span>=&gt;condition: <span class="literal">Yes</span> <span class="keyword">or</span> <span class="literal">No</span>?</span><br><span class="line"><span class="attribute">io</span>=&gt;inputoutput: catch something<span class="built_in">..</span>.</span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(<span class="literal">yes</span>)-&gt;io-&gt;e</span><br><span class="line">cond(<span class="literal">no</span>)-&gt;sub1(right)-&gt;op1</span><br><span class="line">,,,</span><br></pre></td></tr></table></figure></p><p>输出结果如图所示:<br><img src="/2019/05/28/Markdown-flowchart.js画流程图/flowchart01.png" alt="flowchart01.png"></p><p>在markdown语法中，流程图的画法和代码段类似，也就是说，流程图是写在两个,,,之间的。<br>比如说php代码，会是这样一种格式:</p><p align="center">,,,php<br>代码段<br>,,,</p>那么流程图就是这样的:<p align="center">,,,flow<br>代码段<br>,,,`</p><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h3><p>流程图的语法大体分为两部分:</p><ul><li>前面部分用来定义流程图元素；</li><li>后面部分用来连接流程图元素，指定流程图的执行走向。</li></ul><h4 id="2-1-定义元素阶段的语法"><a href="#2-1-定义元素阶段的语法" class="headerlink" title="2.1 定义元素阶段的语法"></a>2.1 定义元素阶段的语法</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tag</span>=&gt;<span class="built_in">type</span>: conten<span class="variable">t:</span>&gt;url</span><br></pre></td></tr></table></figure><p>上例中下面部分代码都是定义元素部分<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">st</span>=&gt;start: Start</span><br><span class="line"><span class="attribute">e</span>=&gt;end: End</span><br><span class="line"><span class="attribute">op1</span>=&gt;operation: My Operation</span><br><span class="line"><span class="attribute">sub1</span>=&gt;subroutine: My Subroutine</span><br><span class="line"><span class="attribute">cond</span>=&gt;condition: <span class="literal">Yes</span> <span class="keyword">or</span> <span class="literal">No</span>?</span><br><span class="line"><span class="attribute">io</span>=&gt;inputoutput: catch something<span class="built_in">..</span>.</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>tag 是流程图中的标签，在第二段连接元素时会用到。名称可以任意，一般为流程的英文缩写和数字的组合。</li><li>type 用来确定标签的类型，=&gt;后面表示类型。由于标签的名称可以任意指定，所以要依赖type来确定标签的类型。</li><li>标签有6种类型：start end operation subroutine condition inputoutput。</li><li>content 是流程图文本框中的描述内容，: 后面表示内容，中英文均可。特别注意，冒号与文本之间一定要有个<em>空格</em>。</li><li>url是一个连接，与框框中的文本相绑定，:&gt;后面就是对应的 url 链接，点击文本时可以通过链接跳转到 url 指定页面。</li></ul><p>开始<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">st</span>=&gt;<span class="keyword">star</span><span class="variable">t:</span> 开始</span><br></pre></td></tr></table></figure></p><p>操作<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">op1</span>=&gt;operation: 操作、执行说明</span><br></pre></td></tr></table></figure></p><p>条件<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cond</span>=&gt;condition: 确认？</span><br></pre></td></tr></table></figure></p><p>结束<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e=&gt;<span class="keyword">end</span>: 结束</span><br></pre></td></tr></table></figure></p><p>URL（貌似 SF 的编辑器不支持）<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e=&gt;点击本结束跳转<span class="symbol">:&gt;http</span><span class="symbol">://https</span><span class="symbol">://segmentfault</span>.com/blog/ingood</span><br></pre></td></tr></table></figure></p><h4 id="2-2-连接流程图元素的语法"><a href="#2-2-连接流程图元素的语法" class="headerlink" title="2.2 连接流程图元素的语法"></a>2.2 连接流程图元素的语法</h4><p>示例代码后面部分</p><p>st-&gt;op1-&gt;cond<br>cond(yes)-&gt;io-&gt;e<br>cond(no)-&gt;sub1(right)-&gt;op1</p><p>连接流程图元素阶段的语法就简单多了，直接用-&gt;来连接两个元素，几点说明如下：<br>说明：</p><ul><li>使用 -&gt; 来连接两个元素</li><li>对于condition类型，有yes和no两个分支，如示例中的cond(yes)和cond(no)</li><li>每个元素可以制定分支走向，默认向下，也可以用right指向右边，如示例中sub1(right)。</li></ul><p>转载声明：<br>本文转载自:<a href="https://segmentfault.com/a/1190000006247465?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006247465?utm_source=tag-newest</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ORB-SLAM2源码分析二</title>
      <link href="/2019/05/28/ORB-SLAM2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8C/"/>
      <url>/2019/05/28/ORB-SLAM2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Tracking-线程分析"><a href="#Tracking-线程分析" class="headerlink" title="Tracking 线程分析"></a><strong>Tracking 线程分析</strong></h2><h3 id="1-Tracking流程图"><a href="#1-Tracking流程图" class="headerlink" title="1. Tracking流程图"></a>1. Tracking流程图</h3><div id="flowchart-0" class="flow-chart"></div><h3 id="2-Tracking-成员变量说明"><a href="#2-Tracking-成员变量说明" class="headerlink" title="2. Tracking 成员变量说明"></a>2. Tracking 成员变量说明</h3><h4 id="2-1-Tracking-状态枚举"><a href="#2-1-Tracking-状态枚举" class="headerlink" title="2.1 Tracking 状态枚举"></a>2.1 Tracking 状态枚举</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">eTrackingState</span>&#123;</span></span><br><span class="line">        SYSTEM_NOT_READY=-<span class="number">1</span>,</span><br><span class="line">        NO_IMAGES_YET=<span class="number">0</span>,</span><br><span class="line">        NOT_INITIALIZED=<span class="number">1</span>,</span><br><span class="line">        OK=<span class="number">2</span>,</span><br><span class="line">        LOST=<span class="number">3</span></span><br><span class="line">    &#125;;</span><br><span class="line">eTrackingState mState;</span><br><span class="line">eTrackingState mLastProcessedState;</span><br></pre></td></tr></table></figure><h4 id="2-2-Tracking-状态枚举-mSensor"><a href="#2-2-Tracking-状态枚举-mSensor" class="headerlink" title="2.2 Tracking 状态枚举 mSensor"></a>2.2 Tracking 状态枚举 <em>mSensor</em></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input sensor:MONOCULAR, STEREO, RGBD</span></span><br><span class="line">    <span class="keyword">int</span> mSensor;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-3-当前帧和当前帧灰度图-mCurrentFrame-mImGray"><a href="#2-3-当前帧和当前帧灰度图-mCurrentFrame-mImGray" class="headerlink" title="2.3 当前帧和当前帧灰度图 mCurrentFrame,mImGray"></a>2.3 当前帧和当前帧灰度图 <em>mCurrentFrame</em>,<em>mImGray</em></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Current Frame</span></span><br><span class="line">    Frame mCurrentFrame;</span><br><span class="line">    cv::Mat mImGray;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-4-初始化的时候两帧图像之间的相关变量"><a href="#2-4-初始化的时候两帧图像之间的相关变量" class="headerlink" title="2.4 初始化的时候两帧图像之间的相关变量"></a>2.4 初始化的时候两帧图像之间的相关变量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialization Variables (Monocular)</span></span><br><span class="line"><span class="comment">// 初始化时前两帧相关变量</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mvIniLastMatches;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mvIniMatches;<span class="comment">// 跟踪初始化时前两帧之间的匹配</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point2f&gt; mvbPrevMatched;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Point3f&gt; mvIniP3D;</span><br><span class="line">Frame mInitialFrame;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-5-Tracking-结果关键帧列表和相对关键帧的位姿列表"><a href="#2-5-Tracking-结果关键帧列表和相对关键帧的位姿列表" class="headerlink" title="2.5 Tracking 结果关键帧列表和相对关键帧的位姿列表"></a>2.5 Tracking 结果关键帧列表和相对关键帧的位姿列表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lists used to recover the full camera trajectory at the end of the execution.</span></span><br><span class="line"><span class="comment">// Basically we store the reference keyframe for each frame and its relative transformation</span></span><br><span class="line"><span class="built_in">list</span>&lt;cv::Mat&gt; mlRelativeFramePoses;</span><br><span class="line"><span class="built_in">list</span>&lt;KeyFrame*&gt; mlpReferences;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; mlFrameTimes;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">bool</span>&gt; mlbLost;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-6-是否开启地图变量-mbOnlyTracking"><a href="#2-6-是否开启地图变量-mbOnlyTracking" class="headerlink" title="2.6 是否开启地图变量 mbOnlyTracking"></a>2.6 是否开启地图变量 <em>mbOnlyTracking</em></h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="literal">True</span> <span class="keyword">if</span> local mapping <span class="keyword">is</span> deactivated <span class="keyword">and</span> we are performing only localization</span><br><span class="line">bool mbOnlyTracking;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-7-只定位时0地图点是否VO变量"><a href="#2-7-只定位时0地图点是否VO变量" class="headerlink" title="2.7 只定位时0地图点是否VO变量"></a>2.7 只定位时0地图点是否VO变量</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// In <span class="keyword">case</span> <span class="keyword">of</span> performing <span class="keyword">only</span> localization, this flag <span class="literal">is</span><span class="built_in"> true</span> <span class="keyword">when</span> there are no<span class="built_in"> matches</span> <span class="keyword">to</span></span><br><span class="line">// points <span class="keyword">in</span> the <span class="keyword">map</span>. Still tracking will continue <span class="keyword">if</span> there are enough<span class="built_in"> matches</span> with temporal points.</span><br><span class="line">// In that <span class="keyword">case</span> we are doing visual odometry. The system will <span class="keyword">try</span> <span class="keyword">to</span> do relocalization <span class="keyword">to</span> recover</span><br><span class="line">// <span class="string">"zero-drift"</span> localization <span class="keyword">to</span> the <span class="keyword">map</span>.</span><br><span class="line">bool mbVO;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-8-另外两个线程的指针-mpLocalMapper，mpLoopClosing"><a href="#2-8-另外两个线程的指针-mpLocalMapper，mpLoopClosing" class="headerlink" title="2.8 另外两个线程的指针 mpLocalMapper，mpLoopClosing"></a>2.8 另外两个线程的指针 <em>mpLocalMapper</em>，<em>mpLoopClosing</em></h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Other Thread Pointers</span><br><span class="line">LocalMapping* mpLocalMapper<span class="comment">;</span></span><br><span class="line">LoopClosing* mpLoopClosing<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-9-ORB特征提取器"><a href="#2-9-ORB特征提取器" class="headerlink" title="2.9 ORB特征提取器"></a>2.9 ORB特征提取器</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ORB</span></span><br><span class="line"><span class="comment">// orb特征提取器，不管单目还是双目，mpORBextractorLeft都要用到</span></span><br><span class="line"><span class="comment">// 如果是双目，则要用到mpORBextractorRight</span></span><br><span class="line"><span class="comment">// 如果是单目，在初始化的时候使用mpIniORBextractor而不是mpORBextractorLeft，</span></span><br><span class="line"><span class="comment">// mpIniORBextractor属性中提取的特征点个数是mpORBextractorLeft的两倍</span></span><br><span class="line">ORBextractor* mpORBextractorLeft, *mpORBextractorRight;</span><br><span class="line">ORBextractor* mpIniORBextractor;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-10-Bow"><a href="#2-10-Bow" class="headerlink" title="2.10 Bow"></a>2.10 Bow</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//BoW</span><br><span class="line">ORBVocabulary* mpORBVocabulary<span class="comment">;</span></span><br><span class="line">KeyFrameDatabase* mpKeyFrameDB<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-11-単目初始器-mpInitializer"><a href="#2-11-単目初始器-mpInitializer" class="headerlink" title="2.11 単目初始器 mpInitializer"></a>2.11 単目初始器 <em>mpInitializer</em></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> Initalization (only <span class="keyword">for</span> monocular)</span><br><span class="line"><span class="regexp">//</span> 单目初始器</span><br><span class="line">Initializer* mpInitializer;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-12-局部地图"><a href="#2-12-局部地图" class="headerlink" title="2.12 局部地图"></a>2.12 局部地图</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Local Map</span></span><br><span class="line">    KeyFrame* mpReferenceKF;<span class="comment">// 当前关键帧就是参考帧</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyFrame*&gt; mvpLocalKeyFrames;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MapPoint*&gt; mvpLocalMapPoints;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-13-SLAM-系统指针"><a href="#2-13-SLAM-系统指针" class="headerlink" title="2.13 SLAM 系统指针"></a>2.13 SLAM 系统指针</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System* mpSystem<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-14-显示相关"><a href="#2-14-显示相关" class="headerlink" title="2.14 显示相关"></a>2.14 显示相关</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Drawers</span><br><span class="line">    Viewer* mpViewer<span class="comment">;</span></span><br><span class="line">    FrameDrawer* mpFrameDrawer<span class="comment">;</span></span><br><span class="line">    MapDrawer* mpMapDrawer<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-15-系统地图-mpMap"><a href="#2-15-系统地图-mpMap" class="headerlink" title="2.15 系统地图 mpMap"></a>2.15 系统地图 <em>mpMap</em></h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//<span class="meta">Map</span></span><br><span class="line">   <span class="meta">Map</span>* mpMap<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-16-相机参数"><a href="#2-16-相机参数" class="headerlink" title="2.16 相机参数"></a>2.16 相机参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Calibration matrix</span></span><br><span class="line">   cv::Mat mK;</span><br><span class="line">   cv::Mat mDistCoef;</span><br><span class="line">   <span class="keyword">float</span> mbf;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-17-新关键帧插入规则"><a href="#2-17-新关键帧插入规则" class="headerlink" title="2.17 新关键帧插入规则"></a>2.17 新关键帧插入规则</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//New KeyFrame rules (according to fps)</span></span><br><span class="line"><span class="keyword">int</span> mMinFrames;</span><br><span class="line"><span class="keyword">int</span> mMaxFrames;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-18-深度截断值"><a href="#2-18-深度截断值" class="headerlink" title="2.18 深度截断值"></a>2.18 深度截断值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Threshold close/far points</span></span><br><span class="line">    <span class="comment">// Points seen as close by the stereo/RGBD sensor are considered reliable</span></span><br><span class="line">    <span class="comment">// and inserted from just one frame. Far points requiere a match in two keyframes.</span></span><br><span class="line">    <span class="keyword">float</span> mThDepth;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-19-深度图因子"><a href="#2-19-深度图因子" class="headerlink" title="2.19 深度图因子"></a>2.19 深度图因子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For RGB-D inputs only. For some datasets (e.g. TUM) the depthmap values are scaled.</span></span><br><span class="line"><span class="keyword">float</span> mDepthMapFactor;;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-20-当前帧有多少特征点成功匹配"><a href="#2-20-当前帧有多少特征点成功匹配" class="headerlink" title="2.20 当前帧有多少特征点成功匹配"></a>2.20 当前帧有多少特征点成功匹配</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Current matches in frame</span></span><br><span class="line">    <span class="keyword">int</span> mnMatchesInliers;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-21-上一关键帧、上一帧和重定位信息"><a href="#2-21-上一关键帧、上一帧和重定位信息" class="headerlink" title="2.21 上一关键帧、上一帧和重定位信息"></a>2.21 上一关键帧、上一帧和重定位信息</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Last Frame, KeyFrame and Relocalisation Info</span></span><br><span class="line">    KeyFrame* mpLastKeyFrame;</span><br><span class="line">    Frame mLastFrame;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mnLastKeyFrameId;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mnLastRelocFrameId;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-22-匀速模型匀速变换矩阵"><a href="#2-22-匀速模型匀速变换矩阵" class="headerlink" title="2.22 匀速模型匀速变换矩阵"></a>2.22 匀速模型匀速变换矩阵</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Motion Model</span></span><br><span class="line">    cv::Mat mVelocity;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-23-相机RGB信息"><a href="#2-23-相机RGB信息" class="headerlink" title="2.23 相机RGB信息"></a>2.23 相机RGB信息</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Color <span class="keyword">order</span> <span class="title">(true</span> RGB, <span class="literal">false</span> BGR, ignored if grayscale)</span><br><span class="line">bool mbRGB;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><h4 id="2-24-临时地图点列表"><a href="#2-24-临时地图点列表" class="headerlink" title="2.24 临时地图点列表"></a>2.24 临时地图点列表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;MapPoint*&gt; mlpTemporalPoints;</span><br></pre></td></tr></table></figure><p>mSeneor 传感器类型</p><p>共47个成员变量</p><h3 id="3-Tracking-类成员函数"><a href="#3-Tracking-类成员函数" class="headerlink" title="3. Tracking 类成员函数"></a>3. Tracking 类成员函数</h3><h4 id="3-1-构造函数-Tracking"><a href="#3-1-构造函数-Tracking" class="headerlink" title="3.1 构造函数 Tracking()"></a>3.1 构造函数 <em>Tracking()</em></h4><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tracking(System* pSys, ORBVocabulary* pVoc, FrameDrawer* pFrameDrawer, MapDrawer* pMapDrawer, <span class="built_in">Map</span>* pMap,</span><br><span class="line">             KeyFrameDatabase* pKFDB, <span class="keyword">const</span> <span class="built_in">string</span> &amp;strSettingPath, <span class="keyword">const</span> <span class="built_in">int</span> sensor);</span><br></pre></td></tr></table></figure><p>执行完构造函数后<br>mState(NO_IMAGES_YET), mSensor(sensor), mbOnlyTracking(false), mbVO(false), mpORBVocabulary(pVoc),mpKeyFrameDB(pKFDB), mpInitializer(static_cast<initializer*>(NULL)), mpSystem(pSys), mpViewer(NULL),mpFrameDrawer(pFrameDrawer), mpMapDrawer(pMapDrawer), mpMap(pMap), mnLastRelocFrameId(0)等13个变量获得初始值。mK，mDistCoef，mbf，mMinFrames，mMaxFrames，mbRGB，mpORBextractorLeft，mpORBextractorRight，mpIniORBextractor，mThDepth， mDepthMapFactor等12个变量获得具体值。</initializer*></p><h4 id="3-2-抓取图片函数-GrabImageMonocular"><a href="#3-2-抓取图片函数-GrabImageMonocular" class="headerlink" title="3.2 抓取图片函数 GrabImageMonocular()"></a>3.2 抓取图片函数 <em>GrabImageMonocular()</em></h4><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Preprocess the input and call Track(). Extract features and performs stereo matching.</span></span><br><span class="line">    cv::Mat GrabImageStereo(<span class="keyword">const</span> cv::Mat &amp;imRectLeft,<span class="keyword">const</span> cv::Mat &amp;imRectRight, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp);</span><br><span class="line">    cv::Mat GrabImageRGBD(<span class="keyword">const</span> cv::Mat &amp;imRGB,<span class="keyword">const</span> cv::Mat &amp;imD, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp);</span><br><span class="line">    cv::Mat GrabImageMonocular(<span class="keyword">const</span> cv::Mat &amp;im, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp);</span><br></pre></td></tr></table></figure><h4 id="3-3-设置三个线程指针函数，关联三个线程"><a href="#3-3-设置三个线程指针函数，关联三个线程" class="headerlink" title="3.3 设置三个线程指针函数，关联三个线程"></a>3.3 设置三个线程指针函数，关联三个线程</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetLocalMapper</span><span class="params">(LocalMapping* pLocalMapper)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetLoopClosing</span><span class="params">(LoopClosing* pLoopClosing)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetViewer</span><span class="params">(Viewer* pViewer)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-4-矫正相机"><a href="#3-4-矫正相机" class="headerlink" title="3.4 矫正相机"></a>3.4 矫正相机</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">Load</span> <span class="keyword">new</span> <span class="keyword">settings</span></span><br><span class="line">// The focal <span class="keyword">length</span> should be similar <span class="keyword">or</span> scale <span class="keyword">prediction</span> will fail <span class="keyword">when</span> projecting points</span><br><span class="line">// TODO: <span class="keyword">Modify</span> MapPoint::PredictScale <span class="keyword">to</span> take <span class="keyword">into</span> <span class="keyword">account</span> focal <span class="keyword">lenght</span></span><br><span class="line"><span class="built_in">void</span> ChangeCalibration(const <span class="keyword">string</span> &amp;strSettingPath);</span><br></pre></td></tr></table></figure><h4 id="3-5-构造函数"><a href="#3-5-构造函数" class="headerlink" title="3.5 构造函数"></a>3.5 构造函数</h4><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tracking(System* pSys, ORBVocabulary* pVoc, FrameDrawer* pFrameDrawer, MapDrawer* pMapDrawer, <span class="built_in">Map</span>* pMap,</span><br><span class="line">             KeyFrameDatabase* pKFDB, <span class="keyword">const</span> <span class="built_in">string</span> &amp;strSettingPath, <span class="keyword">const</span> <span class="built_in">int</span> sensor);</span><br></pre></td></tr></table></figure><h4 id="3-6-InformOnlyTracking-设置是否只跟踪"><a href="#3-6-InformOnlyTracking-设置是否只跟踪" class="headerlink" title="3.6 InformOnlyTracking() 设置是否只跟踪"></a>3.6 <em>InformOnlyTracking()</em> 设置是否只跟踪</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">Use</span> this <span class="keyword">function</span> <span class="keyword">if</span> you have deactivated <span class="keyword">local</span> <span class="keyword">mapping</span> <span class="keyword">and</span> you <span class="keyword">only</span> want <span class="keyword">to</span> localize the camera.</span><br><span class="line">    <span class="built_in">void</span> InformOnlyTracking(const <span class="built_in">bool</span> &amp;flag);</span><br></pre></td></tr></table></figure><h4 id="3-7-Reset-函数清除所有地图点"><a href="#3-7-Reset-函数清除所有地图点" class="headerlink" title="3.7 Reset() 函数清除所有地图点"></a>3.7 <em>Reset()</em> 函数清除所有地图点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-8-Track"><a href="#3-8-Track" class="headerlink" title="3.8 Track()"></a>3.8 <em>Track()</em></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main tracking function. It is independent of the input sensor.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Track</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>跟踪线程的主函数，独立于传感器类型</p><h4 id="3-9-Track初始化函数"><a href="#3-9-Track初始化函数" class="headerlink" title="3.9 Track初始化函数"></a>3.9 Track初始化函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map initialization for stereo and RGB-D</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StereoInitialization</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map initialization for monocular</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MonocularInitialization</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-10-构造函数"><a href="#3-10-构造函数" class="headerlink" title="3.10 构造函数"></a>3.10 构造函数</h4><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tracking(System* pSys, ORBVocabulary* pVoc, FrameDrawer* pFrameDrawer, MapDrawer* pMapDrawer, <span class="built_in">Map</span>* pMap,</span><br><span class="line">             KeyFrameDatabase* pKFDB, <span class="keyword">const</span> <span class="built_in">string</span> &amp;strSettingPath, <span class="keyword">const</span> <span class="built_in">int</span> sensor);</span><br></pre></td></tr></table></figure><h4 id="3-11-初始化単目地图"><a href="#3-11-初始化単目地图" class="headerlink" title="3.11 初始化単目地图"></a>3.11 初始化単目地图</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInitialMapMonocular</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-12-检查"><a href="#3-12-检查" class="headerlink" title="3.12 检查"></a>3.12 检查</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CheckReplacedInLastFrame</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-13-构造函数"><a href="#3-13-构造函数" class="headerlink" title="3.13 构造函数"></a>3.13 构造函数</h4><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tracking(System* pSys, ORBVocabulary* pVoc, FrameDrawer* pFrameDrawer, MapDrawer* pMapDrawer, <span class="built_in">Map</span>* pMap,</span><br><span class="line">             KeyFrameDatabase* pKFDB, <span class="keyword">const</span> <span class="built_in">string</span> &amp;strSettingPath, <span class="keyword">const</span> <span class="built_in">int</span> sensor);</span><br></pre></td></tr></table></figure><h4 id="3-14-通过上一参考关键帧来跟踪图像位姿"><a href="#3-14-通过上一参考关键帧来跟踪图像位姿" class="headerlink" title="3.14 通过上一参考关键帧来跟踪图像位姿"></a>3.14 通过上一参考关键帧来跟踪图像位姿</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TrackReferenceKeyFrame</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-15-更新上一帧"><a href="#3-15-更新上一帧" class="headerlink" title="3.15 更新上一帧"></a>3.15 更新上一帧</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateLastFrame</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-16-通过上一帧来跟踪图像位姿，利用匀速模型"><a href="#3-16-通过上一帧来跟踪图像位姿，利用匀速模型" class="headerlink" title="3.16 通过上一帧来跟踪图像位姿，利用匀速模型"></a>3.16 通过上一帧来跟踪图像位姿，利用匀速模型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TrackWithMotionModel</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-17-跟踪丢失重定位"><a href="#3-17-跟踪丢失重定位" class="headerlink" title="3.17 跟踪丢失重定位"></a>3.17 跟踪丢失重定位</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Relocalization</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-18-更新局部地图信息，更新局部地图，更新局部3D点，更新局部地图关键帧"><a href="#3-18-更新局部地图信息，更新局部地图，更新局部3D点，更新局部地图关键帧" class="headerlink" title="3.18 更新局部地图信息，更新局部地图，更新局部3D点，更新局部地图关键帧"></a>3.18 更新局部地图信息，更新局部地图，更新局部3D点，更新局部地图关键帧</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateLocalMap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateLocalPoints</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateLocalKeyFrames</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-19-跟踪局部地图"><a href="#3-19-跟踪局部地图" class="headerlink" title="3.19 跟踪局部地图"></a>3.19 跟踪局部地图</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TrackLocalMap</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-20-寻找局部地图点"><a href="#3-20-寻找局部地图点" class="headerlink" title="3.20 寻找局部地图点"></a>3.20 寻找局部地图点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SearchLocalPoints</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-21-判定是否需要插入关键帧"><a href="#3-21-判定是否需要插入关键帧" class="headerlink" title="3.21 判定是否需要插入关键帧"></a>3.21 判定是否需要插入关键帧</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NeedNewKeyFrame</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-22-创建新的关键帧"><a href="#3-22-创建新的关键帧" class="headerlink" title="3.22 创建新的关键帧"></a>3.22 创建新的关键帧</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateNewKeyFrame</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-实例化mpTracker"><a href="#4-实例化mpTracker" class="headerlink" title="4. 实例化mpTracker"></a>4. 实例化mpTracker</h3><p>在System构造函数中new一个Tracing对象指针mpTracker，方式如下所示：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Initialize the Tracking thread</span></span><br><span class="line"><span class="comment">//(it will live in the main thread of execution, the one that called this constructor)</span></span><br><span class="line">mpTracker = <span class="keyword">new</span> <span class="type">Tracking</span>(<span class="built_in">this</span>, mpVocabulary, mpFrameDrawer, mpMapDrawer,</span><br><span class="line">                             mpMap, mpKeyFrameDatabase, strSettingsFile, mSensor);</span><br></pre></td></tr></table></figure></p><h4 id="4-1-读取配置文件，构造相机内参-mK"><a href="#4-1-读取配置文件，构造相机内参-mK" class="headerlink" title="4.1 读取配置文件，构造相机内参  mK"></a>4.1 读取配置文件，构造相机内参  <em>mK</em></h4><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cv::FileStorage fSettings(strSettingPath, cv::FileStorage::READ);</span><br><span class="line">   <span class="keyword">float</span> fx = fSettings[<span class="string">"Camera.fx"</span>];</span><br><span class="line">   <span class="keyword">float</span> fy = fSettings[<span class="string">"Camera.fy"</span>];</span><br><span class="line">   <span class="keyword">float</span> cx = fSettings[<span class="string">"Camera.cx"</span>];</span><br><span class="line">   <span class="keyword">float</span> cy = fSettings[<span class="string">"Camera.cy"</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//     |fx  0   cx|</span></span><br><span class="line">   <span class="comment">// K = |0   fy  cy|</span></span><br><span class="line">   <span class="comment">//     |0   0   1 |</span></span><br><span class="line">   cv::Mat K = cv::Mat::eye(<span class="number">3</span>,<span class="number">3</span>,CV_32F);</span><br><span class="line">   K.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">0</span>) = fx;</span><br><span class="line">   K.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">1</span>) = fy;</span><br><span class="line">   K.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,<span class="number">2</span>) = cx;</span><br><span class="line">   K.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>,<span class="number">2</span>) = cy;</span><br><span class="line">   K.copyTo(mK);</span><br></pre></td></tr></table></figure><h4 id="4-2-读取配置文件，构造相机矫正向量-mDistCoef"><a href="#4-2-读取配置文件，构造相机矫正向量-mDistCoef" class="headerlink" title="4.2 读取配置文件，构造相机矫正向量  mDistCoef"></a>4.2 读取配置文件，构造相机矫正向量  <em>mDistCoef</em></h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 图像矫正系数</span><br><span class="line">// [k1 k2 p1 p2 k3]</span><br><span class="line"><span class="built_in">cv</span>::Mat DistCoef(<span class="number">4</span>,<span class="number">1</span>,CV_32F);</span><br><span class="line">DistCoef.<span class="built_in">at</span>&lt;<span class="built_in">float</span>&gt;(<span class="number">0</span>) = fSettings[<span class="string">"Camera.k1"</span>];</span><br><span class="line">DistCoef.<span class="built_in">at</span>&lt;<span class="built_in">float</span>&gt;(<span class="number">1</span>) = fSettings[<span class="string">"Camera.k2"</span>];</span><br><span class="line">DistCoef.<span class="built_in">at</span>&lt;<span class="built_in">float</span>&gt;(<span class="number">2</span>) = fSettings[<span class="string">"Camera.p1"</span>];</span><br><span class="line">DistCoef.<span class="built_in">at</span>&lt;<span class="built_in">float</span>&gt;(<span class="number">3</span>) = fSettings[<span class="string">"Camera.p2"</span>];</span><br><span class="line">const <span class="built_in">float</span> k3 = fSettings[<span class="string">"Camera.k3"</span>];</span><br><span class="line"><span class="keyword">if</span>(k3!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    DistCoef.resize(<span class="number">5</span>);</span><br><span class="line">    DistCoef.<span class="built_in">at</span>&lt;<span class="built_in">float</span>&gt;(<span class="number">4</span>) = k3;</span><br><span class="line">&#125;</span><br><span class="line">DistCoef.copyTo(mDistCoef);</span><br></pre></td></tr></table></figure><h4 id="4-3-读取配置文件，构造相机RGB参数-mbRGB"><a href="#4-3-读取配置文件，构造相机RGB参数-mbRGB" class="headerlink" title="4.3 读取配置文件，构造相机RGB参数 mbRGB"></a>4.3 读取配置文件，构造相机RGB参数 <em>mbRGB</em></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1:RGB 0:BGR</span></span><br><span class="line">    <span class="keyword">int</span> nRGB = fSettings[<span class="string">"Camera.RGB"</span>];</span><br><span class="line">    mbRGB = nRGB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mbRGB)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"- color order: RGB (ignored if grayscale)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"- color order: BGR (ignored if grayscale)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h4 id="4-4-读取配置文件，加载ORB参数-nFeatures、fScaleFactor、nLevels、fIniThFAST、fMinThFAST"><a href="#4-4-读取配置文件，加载ORB参数-nFeatures、fScaleFactor、nLevels、fIniThFAST、fMinThFAST" class="headerlink" title="4.4 读取配置文件，加载ORB参数 nFeatures、fScaleFactor、nLevels、fIniThFAST、fMinThFAST"></a>4.4 读取配置文件，加载ORB参数 <em>nFeatures</em>、<em>fScaleFactor</em>、<em>nLevels</em>、<em>fIniThFAST</em>、<em>fMinThFAST</em></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load ORB parameters</span></span><br><span class="line"><span class="comment">// 每一帧提取的特征点数 1000</span></span><br><span class="line"><span class="keyword">int</span> nFeatures = fSettings[<span class="string">"ORBextractor.nFeatures"</span>];</span><br><span class="line"><span class="comment">// 图像建立金字塔时的变化尺度 1.2</span></span><br><span class="line"><span class="keyword">float</span> fScaleFactor = fSettings[<span class="string">"ORBextractor.scaleFactor"</span>];</span><br><span class="line"><span class="comment">// 尺度金字塔的层数 8</span></span><br><span class="line"><span class="keyword">int</span> nLevels = fSettings[<span class="string">"ORBextractor.nLevels"</span>];</span><br><span class="line"><span class="comment">// 提取fast特征点的默认阈值 20</span></span><br><span class="line"><span class="keyword">int</span> fIniThFAST = fSettings[<span class="string">"ORBextractor.iniThFAST"</span>];</span><br><span class="line"><span class="comment">// 如果默认阈值提取不出足够fast特征点，则使用最小阈值 8</span></span><br><span class="line"><span class="keyword">int</span> fMinThFAST = fSettings[<span class="string">"ORBextractor.minThFAST"</span>];</span><br></pre></td></tr></table></figure><h4 id="4-5-通过nFeatures、fScaleFactor、nLevels、fIniThFAST、fMinThFAST构造特征提取器"><a href="#4-5-通过nFeatures、fScaleFactor、nLevels、fIniThFAST、fMinThFAST构造特征提取器" class="headerlink" title="4.5 通过nFeatures、fScaleFactor、nLevels、fIniThFAST、fMinThFAST构造特征提取器"></a>4.5 通过<em>nFeatures</em>、<em>fScaleFactor</em>、<em>nLevels</em>、<em>fIniThFAST</em>、<em>fMinThFAST</em>构造特征提取器</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tracking过程都会用到mpORBextractorLeft作为特征点提取器</span></span><br><span class="line">mpORBextractorLeft = <span class="keyword">new</span> <span class="type">ORBextractor</span>(nFeatures,fScaleFactor,nLevels,fIniThFAST,fMinThFAST);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是双目，tracking过程中还会用用到mpORBextractorRight作为右目特征点提取器</span></span><br><span class="line"><span class="keyword">if</span>(sensor==System:<span class="type"></span>:STEREO)</span><br><span class="line">    mpORBextractorRight = <span class="keyword">new</span> <span class="type">ORBextractor</span>(nFeatures,fScaleFactor,nLevels,fIniThFAST,fMinThFAST);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在单目初始化的时候，会用mpIniORBextractor来作为特征点提取器</span></span><br><span class="line"><span class="keyword">if</span>(sensor==System:<span class="type"></span>:MONOCULAR)</span><br><span class="line">    mpIniORBextractor = <span class="keyword">new</span> <span class="type">ORBextractor</span>(<span class="number">2</span>*nFeatures,fScaleFactor,nLevels,fIniThFAST,fMinThFAST);</span><br></pre></td></tr></table></figure><h4 id="4-6-读取配置文件，构造相机深度截断阈值和视差因子-mThDepth-mDepthMapFactor"><a href="#4-6-读取配置文件，构造相机深度截断阈值和视差因子-mThDepth-mDepthMapFactor" class="headerlink" title="4.6 读取配置文件，构造相机深度截断阈值和视差因子 mThDepth,mDepthMapFactor"></a>4.6 读取配置文件，构造相机深度截断阈值和视差因子 <em>mThDepth</em>,<em>mDepthMapFactor</em></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sensor==System::STEREO || sensor==System::RGBD)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断一个3D点远/近的阈值 mbf * 35 / fx</span></span><br><span class="line">    mThDepth = mbf*(<span class="keyword">float</span>)fSettings[<span class="string">"ThDepth"</span>]/fx;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Depth Threshold (Close/Far Points): "</span> &lt;&lt; mThDepth &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sensor==System::RGBD)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 深度相机disparity转化为depth时的因子</span></span><br><span class="line">    mDepthMapFactor = fSettings[<span class="string">"DepthMapFactor"</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(mDepthMapFactor)&lt;<span class="number">1e-5</span>)</span><br><span class="line">        mDepthMapFactor=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mDepthMapFactor = <span class="number">1.0f</span>/mDepthMapFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="flowchart-1" class="flow-chart"></div><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 调用构造函数实例化mpTrackere=>end: 得到mCurrentFrame.mTcwop1=>operation: 循环SLAM.TrackMonocular(im,tframe)，对每一帧图像进行trackingop2=>operation: 调用mpTracker->GrabImageMonocular(im,timestamp),抓取每一帧图像op3=>operation: 将RGB图转换为灰度图mImGrayop4=>operation: 利用灰度图构造当前帧mCurrentFrameop5=>operation: 调用track()函数st->op1->op2->op3->op4->op5->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: 调用构造函数实例化 mpTrackere=>end: 得到mpTrackerop1=>operation: 读取配置文件，构造相机内参 mK,相机矫正向量 mDistCoef ,相机RGB参数 mbRGBop2=>operation: 读取配置文件，加载ORB参数 nFeatures、fScaleFactor、nLevels、fIniThFAST、fMinThFASTop3=>operation: 构造特征提取器 mpORBextractorLeft、mpIniORBextractorop4=>operation: 读取配置文件, 构造相机深度截断阈值和视差因子 mThDepth、mDepthMapFactorst->op1->op2->op3->op4->e</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script></p>]]></content>
      
      
      <categories>
          
          <category> ORB-SLAM2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
            <tag> Tracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ORB-SLAM2源码分析一</title>
      <link href="/2019/05/28/ORB-SLAM2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80/"/>
      <url>/2019/05/28/ORB-SLAM2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="主函数说明-mono-kitty-cc"><a href="#主函数说明-mono-kitty-cc" class="headerlink" title="主函数说明 mono_kitty.cc"></a><strong>主函数说明 mono_kitty.cc</strong></h2><h3 id="1-main-入口函数，读取3个文件参数，初始化系统"><a href="#1-main-入口函数，读取3个文件参数，初始化系统" class="headerlink" title="1. main 入口函数，读取3个文件参数，初始化系统"></a>1. <em>main</em> 入口函数，读取3个文件参数，初始化系统</h3><ul><li>strVocFile: 字典词包的路径</li><li>strSettingFile: 系统中装有一些如相机参数、view窗口的配置文件，格式为YAML</li><li>strSequence: 数据集路径</li></ul><h3 id="2-LoadImages-函数"><a href="#2-LoadImages-函数" class="headerlink" title="2. LoadImages 函数"></a>2. <em>LoadImages</em> 函数</h3><p> LoadImages(const string &amp;strPathToSequence, vector<string> &amp;vstrImageFilenames, vector<double> &amp;vTimestamps)<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">LoadImages</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;strPathToSequence, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;vstrImageFilenames, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;vTimestamps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream fTimes;</span><br><span class="line">    <span class="built_in">string</span> strPathTimeFile = strPathToSequence + <span class="string">"/times.txt"</span>;</span><br><span class="line">    fTimes.open(strPathTimeFile.c_str());</span><br><span class="line">    <span class="keyword">while</span>(!fTimes.eof())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        getline(fTimes,s);</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stringstream</span> ss;</span><br><span class="line">            ss &lt;&lt; s;</span><br><span class="line">            <span class="keyword">double</span> t;</span><br><span class="line">            ss &gt;&gt; t;</span><br><span class="line">            vTimestamps.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> strPrefixLeft = strPathToSequence + <span class="string">"/image_0/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nTimes = vTimestamps.size();</span><br><span class="line">    vstrImageFilenames.resize(nTimes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nTimes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; setw(<span class="number">6</span>) &lt;&lt; i;</span><br><span class="line">        vstrImageFilenames[i] = strPrefixLeft + ss.str() + <span class="string">".png"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></double></string></p><p>加载数据集函数，函数执行完vstrImageFileNames是一个存有图片具体位置的vector，位置形式如xxx/xxx/000xxx.png，vTimestamps是存有图片时间戳的vector</p><hr><h3 id="3-实例化-SLAM-系统"><a href="#3-实例化-SLAM-系统" class="headerlink" title="3. 实例化 SLAM 系统"></a>3. 实例化 SLAM 系统</h3><p>加载图片路径完成后，需要实例化一个SLAM系统对象<br>ORB_SLAM2::System SLAM(argv[1],argv[2],ORB_SLAM2::System::MONOCULAR,true);</p><p>System.h 包含了7个类，分别是Viewer， FrameDrawer, Map, Tracking, LocalMapping, LoopClosing 的声明，和System 类的定义， 就像描述的那样，这些类组成了一个系统。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Viewer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrameDrawer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tracking</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalMapping</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoopClosing</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">System</span>;</span></span><br></pre></td></tr></table></figure><h2 id="成员变量说明"><a href="#成员变量说明" class="headerlink" title="成员变量说明"></a>成员变量说明</h2><h3 id="3-1-sensor-枚举"><a href="#3-1-sensor-枚举" class="headerlink" title="3.1 sensor 枚举"></a>3.1 sensor 枚举</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">eSensor</span>&#123;</span></span><br><span class="line">        MONOCULAR=<span class="number">0</span>,</span><br><span class="line">        STEREO=<span class="number">1</span>,</span><br><span class="line">        RGBD=<span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>0,1,2 分别代表传感器的类型</p><h3 id="3-2-System-构造函数"><a href="#3-2-System-构造函数" class="headerlink" title="3.2 System 构造函数"></a>3.2 System 构造函数</h3><p>System(const string &amp;strVocFile, const string &amp;strSettingsFile, const eSensor sensor, const bool bUseViewer = true);</p><p>Monocular System 构造时，读入词包路径，YAML配置文件，设置eSensor类型为Monocular，并启用Viewer线程</p><h3 id="3-3-Tracking-函数"><a href="#3-3-Tracking-函数" class="headerlink" title="3.3 Tracking 函数"></a>3.3 Tracking 函数</h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Proccess the given stereo frame. Images must be synchronized and rectified.</span></span><br><span class="line"><span class="comment">// Input images: RGB (CV_8UC3) or grayscale (CV_8U). RGB is converted to grayscale.</span></span><br><span class="line"><span class="comment">// Returns the camera pose (empty if tracking fails).</span></span><br><span class="line">cv::Mat TrackStereo(<span class="keyword">const</span> cv::Mat &amp;imLeft, <span class="keyword">const</span> cv::Mat &amp;imRight, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process the given rgbd frame. Depthmap must be registered to the RGB frame.</span></span><br><span class="line"><span class="comment">// Input image: RGB (CV_8UC3) or grayscale (CV_8U). RGB is converted to grayscale.</span></span><br><span class="line"><span class="comment">// Input depthmap: Float (CV_32F).</span></span><br><span class="line"><span class="comment">// Returns the camera pose (empty if tracking fails).</span></span><br><span class="line">cv::Mat TrackRGBD(<span class="keyword">const</span> cv::Mat &amp;im, <span class="keyword">const</span> cv::Mat &amp;depthmap, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Proccess the given monocular frame</span></span><br><span class="line"><span class="comment">// Input images: RGB (CV_8UC3) or grayscale (CV_8U). RGB is converted to grayscale.</span></span><br><span class="line"><span class="comment">// Returns the camera pose (empty if tracking fails).</span></span><br><span class="line">cv::Mat TrackMonocular(<span class="keyword">const</span> cv::Mat &amp;im, <span class="keyword">const</span> <span class="keyword">double</span> &amp;timestamp);</span><br></pre></td></tr></table></figure><p>针对不同传感器不同的Tracking。输入图像可以使rgb的也可以是grayscale的（最终读进去都会转化为grayscale的），函数返回值为camera的位姿pose。Tracking 过程是对针对每一幅图像，通过先初始化然后track和优化过程来估计相机误差。</p><h3 id="3-4-定位模式函数"><a href="#3-4-定位模式函数" class="headerlink" title="3.4 定位模式函数"></a>3.4 定位模式函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This stops local mapping thread (map building) and performs only camera tracking.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ActivateLocalizationMode</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// This resumes local mapping thread and performs SLAM again.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeactivateLocalizationMode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>调用ActivateLocalizationMode()将终止mapping线程，开启定位模式，调用后者重启mapping线程。</p><h3 id="3-5-重启与终止函数"><a href="#3-5-重启与终止函数" class="headerlink" title="3.5 重启与终止函数"></a>3.5 重启与终止函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reset the system (clear map)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All threads will be requested to finish.</span></span><br><span class="line"><span class="comment">// It waits until all threads have finished.</span></span><br><span class="line"><span class="comment">// This function must be called before saving the trajectory.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Reset()函数将清空map，Shutdown()函数可以终止所有线程，在保存相机轨迹之前需要调用此函数。</p><h3 id="3-6-SaveTrajectory-函数"><a href="#3-6-SaveTrajectory-函数" class="headerlink" title="3.6 SaveTrajectory 函数"></a>3.6 SaveTrajectory 函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Save camera trajectory in the TUM RGB-D dataset format.</span><br><span class="line">// Only for stereo and RGB-D. This method does not work for monocular.</span><br><span class="line">// <span class="keyword">Call</span> <span class="keyword">first</span> <span class="keyword">Shutdown</span>()</span><br><span class="line">// See <span class="keyword">format</span> details <span class="keyword">at</span>: <span class="keyword">http</span>://vision.in.tum.de/<span class="keyword">data</span>/datasets/rgbd-dataset</span><br><span class="line"><span class="built_in">void</span> SaveTrajectoryTUM(const <span class="keyword">string</span> &amp;filename);</span><br><span class="line"></span><br><span class="line">// Save keyframe poses in the TUM RGB-D dataset format.</span><br><span class="line">// This method works for all sensor input.</span><br><span class="line">// <span class="keyword">Call</span> <span class="keyword">first</span> <span class="keyword">Shutdown</span>()</span><br><span class="line">// See <span class="keyword">format</span> details <span class="keyword">at</span>: <span class="keyword">http</span>://vision.in.tum.de/<span class="keyword">data</span>/datasets/rgbd-dataset</span><br><span class="line"><span class="built_in">void</span> SaveKeyFrameTrajectoryTUM(const <span class="keyword">string</span> &amp;filename);</span><br><span class="line"></span><br><span class="line">// Save camera trajectory in the KITTI dataset format.</span><br><span class="line">// Only for stereo and RGB-D. This method does not work for monocular.</span><br><span class="line">// <span class="keyword">Call</span> <span class="keyword">first</span> <span class="keyword">Shutdown</span>()</span><br><span class="line">// See <span class="keyword">format</span> details <span class="keyword">at</span>: <span class="keyword">http</span>://www.cvlibs.net/datasets/kitti/eval_odometry.php</span><br><span class="line"><span class="built_in">void</span> SaveTrajectoryKITTI(const <span class="keyword">string</span> &amp;filename);</span><br><span class="line"></span><br><span class="line">// TODO: Save/<span class="keyword">Load</span> functions</span><br><span class="line">// SaveMap(const <span class="keyword">string</span> &amp;filename);</span><br><span class="line">// LoadMap(const string &amp;filename);</span><br></pre></td></tr></table></figure><p>把相机轨迹保存成相应数据集的格式，系统调用此函数时先shutdown SLAM系统，mono_kittti中save函数用的是SaveKeyFrameTrajectoryTUM，这个函数看起来像是只能用于TUM数据集，但三种传感器均适合。</p><h3 id="4-System-private-成员变量说明"><a href="#4-System-private-成员变量说明" class="headerlink" title="4 System private 成员变量说明"></a>4 System private 成员变量说明</h3><h3 id="4-1-eSensor"><a href="#4-1-eSensor" class="headerlink" title="4.1 eSensor"></a>4.1 eSensor</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input sensor</span></span><br><span class="line">eSensor mSensor;</span><br></pre></td></tr></table></figure><p>输入的传感器类型</p><h3 id="4-2-mpVocabulary"><a href="#4-2-mpVocabulary" class="headerlink" title="4.2 mpVocabulary"></a>4.2 mpVocabulary</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ORB vocabulary used <span class="keyword">for</span> place recognition <span class="keyword">and</span> <span class="built_in">feature</span> matching.</span><br><span class="line">ORBVocabulary* mpVocabulary;</span><br></pre></td></tr></table></figure><p>用于位置识别和特征匹配的系统词包</p><h3 id="4-3-mpKeyFrameDatabase"><a href="#4-3-mpKeyFrameDatabase" class="headerlink" title="4.3 mpKeyFrameDatabase"></a>4.3 mpKeyFrameDatabase</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// KeyFrame database <span class="keyword">for</span> place recognition (relocalization <span class="keyword">and</span> <span class="keyword">loop</span> detection).</span><br><span class="line">KeyFrameDatabase* mpKeyFrameDatabase;</span><br></pre></td></tr></table></figure><p>用于位置识别，重定位，回环检测的关键帧数据集</p><h3 id="4-4-mpMap"><a href="#4-4-mpMap" class="headerlink" title="4.4 mpMap"></a>4.4 mpMap</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">Map</span> structure that stores the pointers <span class="keyword">to</span> <span class="keyword">all</span> KeyFrames <span class="keyword">and</span> MapPoints.</span><br><span class="line"><span class="keyword">Map</span>* mpMap;</span><br></pre></td></tr></table></figure><p>存储系统关键帧的指针和地图点的指针</p><h3 id="4-5-mpTracker"><a href="#4-5-mpTracker" class="headerlink" title="4.5 mpTracker"></a>4.5 mpTracker</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Tracker. It receives a frame and computes the associated camera pose.</span><br><span class="line">// It also decides when to <span class="keyword">insert</span> a <span class="keyword">new</span> keyframe, <span class="keyword">create</span> <span class="keyword">some</span> <span class="keyword">new</span> MapPoints <span class="keyword">and</span></span><br><span class="line">// performs relocalization <span class="keyword">if</span> <span class="keyword">tracking</span> fails.</span><br><span class="line"><span class="keyword">Tracking</span>* mpTracker;</span><br></pre></td></tr></table></figure><p>Tracker 接受一帧图像并计算相机位姿，决定什么时候需要插入关键帧，创建地图点并且执行重定位如果跟踪失败。</p><h3 id="4-6-mpLocalMapper"><a href="#4-6-mpLocalMapper" class="headerlink" title="4.6 mpLocalMapper"></a>4.6 mpLocalMapper</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Local Mapper. <span class="keyword">It </span>manages the local <span class="meta">map</span> <span class="keyword">and </span>performs local <span class="keyword">bundle </span>adjustment.</span><br><span class="line"><span class="symbol">LocalMapping</span>* mpLocalMapper<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>局部地图管理器，mpLocalMapper，管理局部地图并进行局部BA。</p><h3 id="4-7-mpLoopCloser"><a href="#4-7-mpLoopCloser" class="headerlink" title="4.7 mpLoopCloser"></a>4.7 mpLoopCloser</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Loop Closer. It searches loops <span class="keyword">with</span> every <span class="keyword">new</span> keyframe. <span class="keyword">If</span> there <span class="keyword">is</span> a <span class="keyword">loop</span> it performs</span><br><span class="line">// a pose graph optimization <span class="keyword">and</span> <span class="keyword">full</span> bundle adjustment (<span class="keyword">in</span> a <span class="keyword">new</span> <span class="keyword">thread</span>) afterwards.</span><br><span class="line">LoopClosing* mpLoopCloser;</span><br></pre></td></tr></table></figure><p>回环检测器，每次获取关键帧后都会进行回环检测，如果存在回环的话就执行位姿图的优化并且进行全局BA优化</p><h3 id="4-8-mpViewer-mpFrameDrawer-mpMapDrawer"><a href="#4-8-mpViewer-mpFrameDrawer-mpMapDrawer" class="headerlink" title="4.8 mpViewer,mpFrameDrawer,mpMapDrawer"></a>4.8 mpViewer,mpFrameDrawer,mpMapDrawer</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The viewer draws the map and the current camera pose. It uses Pangolin.</span></span><br><span class="line">Viewer* mpViewer;</span><br><span class="line"></span><br><span class="line">FrameDrawer* mpFrameDrawer;</span><br><span class="line">MapDrawer* mpMapDrawer;</span><br></pre></td></tr></table></figure><p>视图显示</p><h3 id="4-9-系统线程"><a href="#4-9-系统线程" class="headerlink" title="4.9 系统线程"></a>4.9 系统线程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System threads: Local Mapping, Loop Closing, Viewer.</span></span><br><span class="line"><span class="comment">// The Tracking thread "lives" in the main execution thread that creates the System object.</span></span><br><span class="line"><span class="built_in">std</span>::thread* mptLocalMapping;</span><br><span class="line"><span class="built_in">std</span>::thread* mptLoopClosing;</span><br><span class="line"><span class="built_in">std</span>::thread* mptViewer;</span><br></pre></td></tr></table></figure><h3 id="4-10-Reset-flag"><a href="#4-10-Reset-flag" class="headerlink" title="4.10 Reset flag"></a>4.10 Reset flag</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reset flag</span></span><br><span class="line"><span class="built_in">std</span>::mutex mMutexReset;</span><br><span class="line"><span class="keyword">bool</span> mbReset;</span><br></pre></td></tr></table></figure><h3 id="4-11-Change-mode-flags"><a href="#4-11-Change-mode-flags" class="headerlink" title="4.11 Change mode flags"></a>4.11 Change mode flags</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change mode flags</span></span><br><span class="line"><span class="built_in">std</span>::mutex mMutexMode;</span><br><span class="line"><span class="keyword">bool</span> mbActivateLocalizationMode;</span><br><span class="line"><span class="keyword">bool</span> mbDeactivateLocalizationMode;</span><br></pre></td></tr></table></figure><h3 id="5-实例化SLAM-System构造函数"><a href="#5-实例化SLAM-System构造函数" class="headerlink" title="5. 实例化SLAM-System构造函数"></a>5. 实例化SLAM-System构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System::System(<span class="keyword">const</span> <span class="built_in">string</span> &amp;strVocFile, <span class="keyword">const</span> <span class="built_in">string</span> &amp;strSettingsFile, <span class="keyword">const</span> eSensor sensor,</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">bool</span> bUseViewer):mSensor(sensor),mbReset(<span class="literal">false</span>),mbActivateLocalizationMode(<span class="literal">false</span>),</span><br><span class="line">               mbDeactivateLocalizationMode(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>System 构造函数用于实例化一个SALM系统，开启相机跟踪(Tracking)，局部建图(Local Mapping)，回环检测(Loop Closing)，和可视化界面(Viewer)的线程。</p><h3 id="5-1-初始形参传递"><a href="#5-1-初始形参传递" class="headerlink" title="5.1 初始形参传递"></a>5.1 初始形参传递</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mSensor</span><span class="params">(sensor)</span></span>,</span><br><span class="line"><span class="function"><span class="title">mbReset</span><span class="params">(false)</span></span>,</span><br><span class="line"><span class="function"><span class="title">mbActivateLocalizationMode</span><span class="params">(false)</span></span>,</span><br><span class="line"><span class="function"><span class="title">mbDeactivateLocalizationMode</span><span class="params">(false)</span></span></span><br></pre></td></tr></table></figure><p>sensor是传进来的形参，是前面枚举体中三种传感器的一个，这里为MONOCULAR，它传递给了mSensor，这是一个System类的隐含成员变量，两种变量类型一样。<br>mpViewer是System类的隐含成员变量，Viewer类指针，这里赋空。<br>mbReset，mbActivateLocalizationMode，mbDeactivateLocalizationMode均为bool型，赋false。</p><h3 id="5-2-初始化数据库"><a href="#5-2-初始化数据库" class="headerlink" title="5.2 初始化数据库"></a>5.2 初始化数据库</h3><ul><li><p>1 初始化词包 <strong><em>mpVocabulary</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Load ORB Vocabulary</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Loading ORB Vocabulary. This could take a while..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    mpVocabulary = <span class="keyword">new</span> ORBVocabulary();</span><br><span class="line">    <span class="keyword">bool</span> bVocLoad = <span class="literal">false</span>; <span class="comment">// chose loading method based on file extension</span></span><br><span class="line">    <span class="keyword">if</span> (has_suffix(strVocFile, <span class="string">".txt"</span>))</span><br><span class="line">  bVocLoad = mpVocabulary-&gt;loadFromTextFile(strVocFile);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(has_suffix(strVocFile, <span class="string">".bin"</span>))</span><br><span class="line">  bVocLoad = mpVocabulary-&gt;loadFromBinaryFile(strVocFile);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  bVocLoad = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(!bVocLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Wrong path to vocabulary. "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to open at: "</span> &lt;&lt; strVocFile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Vocabulary loaded!"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p>2 用<strong>词包数据库</strong>来初始化关键帧数据库（用于<strong>重定位</strong>和<strong>回环检测</strong>）<strong><em>mpKeyFrameDatabase</em></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//<span class="keyword">Create</span> KeyFrame <span class="keyword">Database</span></span><br><span class="line">    mpKeyFrameDatabase = <span class="keyword">new</span> KeyFrameDatabase(*mpVocabulary);</span><br></pre></td></tr></table></figure></li><li><p>3 初始化一个Map类对象 ，该类用于存储指向所有<strong>关键帧</strong>和<strong>地图点</strong>的指针 <strong><em>mpMap</em></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//<span class="keyword">Create</span> the <span class="keyword">Map</span></span><br><span class="line">    mpMap = <span class="keyword">new</span> <span class="keyword">Map</span>();</span><br></pre></td></tr></table></figure></li><li><p>4 初始化画图工具，用于可视化 <strong><em>mpFrameDrawer</em></strong>、<strong><em>mpMapDrawer</em></strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Create Drawers. These are used by the Viewer</span></span><br><span class="line">    mpFrameDrawer = <span class="keyword">new</span> <span class="type">FrameDrawer</span>(mpMap);</span><br><span class="line">    mpMapDrawer = <span class="keyword">new</span> <span class="type">MapDrawer</span>(mpMap, strSettingsFile);</span><br></pre></td></tr></table></figure></li><li><p>5 初始化Tracking线程，<strong>主线程</strong>，使用this指针（只初始化不启动，启动在main函数里TrackMonocular()启动）</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Initialize the Tracking thread</span></span><br><span class="line"><span class="comment">//(it will live in the main thread of execution, the one that called this constructor)</span></span><br><span class="line">    mpTracker = <span class="keyword">new</span> <span class="type">Tracking</span>(<span class="built_in">this</span>, mpVocabulary, mpFrameDrawer, mpMapDrawer,</span><br><span class="line">                             mpMap, mpKeyFrameDatabase, strSettingsFile, mSensor);</span><br></pre></td></tr></table></figure></li><li><p>6 初始化Local Mapping线程并启动（这里mSensor传入MONOCULAR）<strong><em>mpLocalMapper</em></strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Initialize the Local Mapping thread and launch</span></span><br><span class="line">   mpLocalMapper = <span class="literal">new</span> LocalMapping(mpMap, mSensor==MONOCULAR);</span><br><span class="line">   mptLocalMapping = <span class="literal">new</span> <span class="keyword">thread</span>(&amp;ORB_SLAM2<span class="type">::LocalMapping</span><span class="type">::Run</span>,mpLocalMapper);</span><br></pre></td></tr></table></figure></li><li><p>7 初始化Loop Closing线程并启动（这里mSensor传入的不是MONOCULAR）<strong><em>mptLoopClosing</em></strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Initialize the Loop Closing thread and launch</span></span><br><span class="line">mpLoopCloser = <span class="literal">new</span> LoopClosing(mpMap, mpKeyFrameDatabase, mpVocabulary, mSensor!=MONOCULAR);</span><br><span class="line">mptLoopClosing = <span class="literal">new</span> <span class="keyword">thread</span>(&amp;ORB_SLAM2<span class="type">::LoopClosing</span><span class="type">::Run</span>, mpLoopCloser);</span><br></pre></td></tr></table></figure></li><li><p>8 初始化Viewer线程并启动，也使用了this指针；给Tracking线程设置Viewer</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Initialize the Viewer thread and launch</span><br><span class="line">    mpViewer = new Viewer(<span class="name">this</span>, mpFrameDrawer,mpMapDrawer,mpTracker,strSettingsFile)<span class="comment">;</span></span><br><span class="line">    if(<span class="name">bUseViewer</span>)</span><br><span class="line">        mptViewer = new thread(<span class="name">&amp;Viewer</span>:<span class="symbol">:Run</span>, mpViewer)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    mpTracker-&gt;SetViewer(<span class="name">mpViewer</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>9 <strong><em>mpTracker</em></strong>，<strong><em>mpLocalMapper</em></strong>，<strong><em>mptLoopClosing</em></strong>三个线程每两个线程之间设置指针相互关联</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Set pointers between threads</span></span><br><span class="line">   <span class="function"><span class="title">mpTracker</span>-&gt;</span>SetLocalMapper(mpLocalMapper);</span><br><span class="line">   <span class="function"><span class="title">mpTracker</span>-&gt;</span>SetLoopClosing(mpLoopCloser);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">mpLocalMapper</span>-&gt;</span>SetTracker(mpTracker);</span><br><span class="line">   <span class="function"><span class="title">mpLocalMapper</span>-&gt;</span>SetLoopCloser(mpLoopCloser);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">mpLoopCloser</span>-&gt;</span>SetTracker(mpTracker);</span><br><span class="line">   <span class="function"><span class="title">mpLoopCloser</span>-&gt;</span>SetLocalMapper(mpLocalMapper);</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-循环Tracking"><a href="#6-循环Tracking" class="headerlink" title="6. 循环Tracking"></a>6. 循环Tracking</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Main loop</span></span><br><span class="line">    cv::Mat im;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ni=<span class="number">0</span>; ni&lt;nImages; ni++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Read image from file</span></span><br><span class="line">        im = cv::imread(vstrImageFilenames[ni],CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">        <span class="keyword">double</span> tframe = vTimestamps[ni];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(im.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Failed to load image at: "</span> &lt;&lt; vstrImageFilenames[ni] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILEDWITHC11</span></span><br><span class="line">        <span class="built_in">std</span>::chrono::steady_clock::time_point t1 = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">std</span>::chrono::monotonic_clock::time_point t1 = <span class="built_in">std</span>::chrono::monotonic_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pass the image to the SLAM system</span></span><br><span class="line">        SLAM.TrackMonocular(im,tframe);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILEDWITHC11</span></span><br><span class="line">        <span class="built_in">std</span>::chrono::steady_clock::time_point t2 = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">std</span>::chrono::monotonic_clock::time_point t2 = <span class="built_in">std</span>::chrono::monotonic_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ttrack= <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; &gt;(t2 - t1).count();</span><br><span class="line"></span><br><span class="line">        vTimesTrack[ni]=ttrack;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait to load the next frame</span></span><br><span class="line">        <span class="keyword">double</span> T=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ni&lt;nImages<span class="number">-1</span>)</span><br><span class="line">            T = vTimestamps[ni+<span class="number">1</span>]-tframe;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ni&gt;<span class="number">0</span>)</span><br><span class="line">            T = tframe-vTimestamps[ni<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ttrack&lt;T)</span><br><span class="line">            this_thread::sleep_for(<span class="built_in">std</span>::chrono::microseconds((<span class="keyword">int</span>)((T-ttrack)*<span class="number">1e6</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop all threads</span></span><br><span class="line">    SLAM.Shutdown();</span><br></pre></td></tr></table></figure><p>上述分为两步：读图、Tracking，其中有一部分代码（注释 //Wait to load the next frame 后）目的是为了模拟真实时间状况，如果tracking过快，则下一帧可能还没来，所以要“睡” T-ttrack 秒等待装载下一帧图片。每次tracking只处理一帧图片。</p>]]></content>
      
      
      <categories>
          
          <category> ORB-SLAM2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
            <tag> Tracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git简单攻略</title>
      <link href="/2019/05/24/git%E7%AE%80%E5%8D%95%E6%94%BB%E7%95%A5/"/>
      <url>/2019/05/24/git%E7%AE%80%E5%8D%95%E6%94%BB%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="git全局用户申明"><a href="#git全局用户申明" class="headerlink" title="git全局用户申明"></a>git全局用户申明</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"Your Name"</span></span><br><span class="line">git<span class="built_in"> config </span>--global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure><h3 id="创建管理库"><a href="#创建管理库" class="headerlink" title="创建管理库"></a>创建管理库</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git init</span></span><br></pre></td></tr></table></figure><h3 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> reamde.md</span></span><br></pre></td></tr></table></figure><h3 id="提交文件到仓库"><a href="#提交文件到仓库" class="headerlink" title="提交文件到仓库"></a>提交文件到仓库</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">"message"</span></span><br></pre></td></tr></table></figure><p>为什么git提交文件需要add和commit两步呢，因为commit可以一次提交很多次add不同的文件，比如<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add file1.txt</span><br><span class="line">git add file2<span class="selector-class">.txt</span> file3.txt</span><br><span class="line">git commit -m <span class="string">"add 3files"</span></span><br></pre></td></tr></table></figure></p><h3 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git status</span></span><br></pre></td></tr></table></figure><h3 id="查看文件修改内容"><a href="#查看文件修改内容" class="headerlink" title="查看文件修改内容"></a>查看文件修改内容</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">diff</span> <span class="selector-tag">readme</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>以便确定回退到哪个版本。</p><h3 id="查看命令历史"><a href="#查看命令历史" class="headerlink" title="查看命令历史"></a>查看命令历史</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git reflog</span></span><br></pre></td></tr></table></figure><p>以便确定回到未来的哪个版本。</p><h3 id="版本指针"><a href="#版本指针" class="headerlink" title="版本指针"></a>版本指针</h3><p>HEAD指向的版本就是当前的版本，HEAD^指向前一个版本，HEAD^^指向前前版本，HEAD~100指向第前100个版本。因此，git允许我们在历史之间穿梭。</p><h3 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard commit_id</span></span><br></pre></td></tr></table></figure><h3 id="丢弃工作区的修改"><a href="#丢弃工作区的修改" class="headerlink" title="丢弃工作区的修改"></a>丢弃工作区的修改</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="comment">-- file</span></span><br></pre></td></tr></table></figure><p>命令<code>git checkout -- readme.txt</code>意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><h3 id="从暂存区回到工作区"><a href="#从暂存区回到工作区" class="headerlink" title="从暂存区回到工作区"></a>从暂存区回到工作区</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="keyword">HEAD</span> readme.txt</span><br></pre></td></tr></table></figure><p>如果你把文件git add到暂存区，但是还没有git commit到仓库，可以使用git reset HEAD file 将暂存区的修改撤销掉，重新放回到工作区。<br>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout — file。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">rm</span> <span class="keyword">test</span>.txt</span><br><span class="line">git commit -<span class="keyword">m</span> <span class="string">"remove test.txt"</span></span><br></pre></td></tr></table></figure><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：rm test.txt。这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了。</p><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit，现在，文件就从版本库中被删除了。</p><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="comment">-- test.txt</span></span><br></pre></td></tr></table></figure></p><p>小提示：先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。<br>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！ </file></file></p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> origin git@github.com:hahaha/hahaha.git</span></span><br></pre></td></tr></table></figure><h3 id="把本地库的所有内容推送到远程库上"><a href="#把本地库的所有内容推送到远程库上" class="headerlink" title="把本地库的所有内容推送到远程库上"></a>把本地库的所有内容推送到远程库上</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> -u <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><h3 id="提交仓库到到远程"><a href="#提交仓库到到远程" class="headerlink" title="提交仓库到到远程"></a>提交仓库到到远程</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>@github.com:hahaha/gitskills.git</span><br></pre></td></tr></table></figure><p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。<br>首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：<br>我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件：<br>现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：</p><p>注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了：</p><h3 id="转载申明"><a href="#转载申明" class="headerlink" title="转载申明"></a>转载申明</h3><p>本文转载自廖雪峰的博客：[<a href="https://www.liaoxuefeng.com" target="_blank" rel="noopener">https://www.liaoxuefeng.com</a>]</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EKF详解</title>
      <link href="/2019/05/23/EKF%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/05/23/EKF%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h4 id="1-高斯函数"><a href="#1-高斯函数" class="headerlink" title="1. 高斯函数"></a>1. 高斯函数</h4><p>\begin{equation}<br>p(x) = \det(2\pi\Sigma)^{- \frac {1}{2} }\exp{ \{ -\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu) \}}<br>\label{eq:Gaussion}<br>\end{equation}</p><p>所有的高斯技术都共享了基本思想，即置信度用多元正态分布来表示。$x$的密度用两个参数来表示，均值$\mu$和协方差$\Sigma$，均值$\mu$是一个向量，它与状态$x$的维数相同。协方差是对称半正定的二次型。其维数等于状态$x$的维数的二次方。高斯滤波中的参数均值和方差称为矩参数，这是因为均值和方差是概率分布的一阶矩和二阶矩；正态分布的其他矩都是零。</p><h4 id="2-线性高斯系统"><a href="#2-线性高斯系统" class="headerlink" title="2. 线性高斯系统"></a>2. 线性高斯系统</h4><p>KF是由Swerling（1950）和Kalman（1960）作为线性高斯系统中的预测和滤波技术而发明的，是用矩来定义的。<br>KF用矩参数来表示置信度：在时刻$t$，置信度用均值$\mu_t$和方差$\Sigma_t$表示、如果除了贝叶斯滤波的马尔科夫假设以外，还具有如下的三个特性，则后验就是高斯的。</p><hr><ul><li><p>状态转移概率$p(x_t | u_t, x_{t-1})$必须是带有随机高斯噪声的参数的线性函数，可有下式表示:<br>\begin{equation}<br>x_t = A_tx_{t-1} + B_tu_t + \varepsilon_t<br>\label{eq:motion}<br>\end{equation}<br>式中，$x_t$和$x_{t-1}$都是状态向量，它们都是$n$维列向量；$u_t$为时刻$t$的控制向量。式(2)中，$A_t$为$n \times n$的矩阵，$B_t$为$n \times m$的矩阵，$n$为状态向量$x_t$的维数，$m$为控制向量$u_t$的维数。式(2)中的随机变量\varepsilon_t是一个高斯随机向量，表示由状态转移引入的不确定性。其维数与状态向量维数相同，均值为0，方差用$R_t$表示。式(2)中的状态转移概率称为线性高斯，反映了它与带有附加高斯噪声的自变量呈线性关系。<br>式(2)定义了状态转移概率$p(x_t | u_t, x_{t-1})$。这个概率可由公式(2)带入到多元正态分布的定义式(1)来得到。后验状态的均值由$A_tx_{t-1} + B_tu_t$给定，方差由$R_t$给定：<br>\begin{equation}<br>p(x_t | u_t, x_{t-1}) = \det(2\pi R_t)^{- \frac {1}{2} }\exp{ \{ -\frac{1}{2}(x_t-A_tx_{t-1} - B_tu_t)^TR_t^{-1}(x_t-A_tx_{t-1} - B_tu_t) \}}<br>\label{eq:status}<br>\end{equation}</p></li><li><p>观测概率$p(z_t | x_t)$也与带有高斯噪声的自变量呈线性关系：<br>\begin{equation}<br>z_t = C_tx_t + \delta _t<br>\label{eq:project}<br>\end{equation}<br>式中，$C_t$为$k \times n$的矩阵，$k$为观测向量$z_t$的维数；向量$\delta _t$为观测噪声。$\delta _t$服从均值为0、方差为$Q_t$的多变量高斯分布。因此观测概率由下面的多元正态分布给定：<br>\begin{equation}<br>p(z_t | x_t) = \det(2\pi Q_t)^{- \frac {1}{2} }\exp{ \{ -\frac{1}{2}(z_t - C_tx_t)^TQ_t^{-1}(z_t-C_tx_t) \}}<br>\label{eq:measure}<br>\end{equation}</p></li><li><p>最后，初始置信度必须${\rm bel}(x_0)$必须是正态分布的。这里用$\mu_0$表示初始置信度的均值，用$\Sigma_0$表示协方差：<br>\begin{equation}<br>{\rm bel}(x_0) = p (x_0)= \det(2\pi \Sigma_0)^{- \frac {1}{2} }\exp{ \{ -\frac{1}{2}(x_0 - \mu_0)^T\Sigma_0^{-1}(x_0-\mu_0) \}}<br>\label{eq:initial}<br>\end{equation}</p></li></ul><p>这三个假设足以保证后验${\rm bel}(x_t)$在任何时刻$t$总符合高斯分布。</p><h4 id="3-KF算法-Kalman-fliter-algorithm"><a href="#3-KF算法-Kalman-fliter-algorithm" class="headerlink" title="3. KF算法(Kalman fliter algorithm)"></a>3. KF算法(Kalman fliter algorithm)</h4><p>KF算法如图所示，KF表示均值为$\mu_t$、方差为$\Sigma_t$的状态量在时刻$t$的置信度{\rm bel}(x_t)。KF的输入是$t-1$时刻的置信度，其均值和方差分别用$\mu_{t-1}$和$\Sigma_{t-1}$表示。为了更新这些参数，KF需要控制向量$u_t$和测量向量$z_t$。输出的是时刻$t$的置信度，均值为$\mu_t$，方差为$\Sigma_t$。</p><blockquote><p>Algorithm Kalman_filter($\mu_{t-1}$,$\Sigma_{t-1}$,$u_t$,$z_t$):</p></blockquote><h4 id="3-3-线性高斯系统"><a href="#3-3-线性高斯系统" class="headerlink" title="3.3 线性高斯系统"></a>3.3 线性高斯系统</h4>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
            <tag> EKF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/05/22/hello-world/"/>
      <url>/2019/05/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
